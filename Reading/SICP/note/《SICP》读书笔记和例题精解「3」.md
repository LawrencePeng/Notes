title: 《SICP》读书笔记和例题精解「3」
category: 读书
tag: [读书, 笔记, SICP, 精解]
------

这是《SICP》的最后一章。《SICP》的第四、五章主要讲解meta-programming和Scheme的一个实现。虽然它们都是很有趣的内容，不过考虑到其实现的方式不够理想。所以这次的《SICP》笔记将不会讲解这一部分的内容。有兴趣的可以购书或在MIT的《SICP》官网上查阅相关资料学习。

主题: 模块化

# 第三章 in a nutshell


前两章的学习主要围绕**抽象**这一个CS中控制复杂度很重要的概念进行讲解。然而如果要构建一个大的系统，仅仅是抽象并不足以让我们将复杂度控制在一个合理的范围内。所以我们需要一个能模块化的方式，让组件间高内聚低耦合，才能让我们的单个模块的开发不受其他模块的变化的影响。

书中介绍了两种常用的组织方式:

1. 对象 -- 系统是对象间的作用。 --OO的思想
2. 流 -- FP的思想


# 笔记

## 赋值和局部状态

如果我们要通过对象来实现模块化，那么，对象自身需要能存储局部变量。因此，就有了状态的概念。

我们很容易就想到状态对应的另一个概念，赋值。

scheme用set!过程来标示。

其语法是(set! name new-value)

不难让它和其他语言中对应的赋值操作对应起来。

我们的状态的概念对于前面的概念是一个巨大的冲击。状态的引入，标示符变成了一个标签，其指代一个位置，而非一个不可变的值。

**这种状态的概念有它的好处。**这种方式能让模块化更加的容易。让状态可以被隐藏起来。我们可以用局部状态变量来表示一个对象的状态本身，用赋值来模拟现实中状态的变化。

与所有状态都必须显示地操作和传递额外的方式相比，通过引进赋值和将状态隐藏的局部变量的技术，能让我们的系统更加模块化。

**然而，我们为此付出的代价是沉重的。**使用状态让我们失去了引用透明性。即标示符即是值，可以被替换。不难想见，前两章的代换模型对于使用了赋值的程序是不适用的。为此，我们需要一种新的模型来解释带有状态概念的取值。

## 环境模型

这个模型就是环境模型。

环境首先引入了环境这个概念，其类似于JS、Python等语言中的环境概念。一个过程的声明时与其外层环境进行了绑定。在其调用时，会新建一个独立的环境，其约束的值是其绑定环境中取得的对应的值。一个过程在多次调用中，新建的环境是不相互干扰的。(要不怎么是独立。。。)这为局部状态的存在提供了可能。如果在其绑定的环境中没能够取得所需要的约束，那么就会递归地寻找父环境，直到找到所需要的约束。(有时候，会需要显式声明约束的条件，而不是递归的查找下去，所以Python中有global、non-local等关键字。。。)

环境模型已经解释清楚了以局部过程定义作为模块化的有用技术中的两个关键性质:

- 局部过程的名字不会与包容它们的过程之外的名字互相干扰，这是因为这些局部过程名都是在该过程运行时创建的过程里面约束的，而不是在全局变量里约束的。
- 局部过程只需将包含着它们的过程作为形参作为自由变量，就可以访问该过程的实际参数。这是因为对于局部变量体的求值所在的环境是外围过程求值所在的环境的下属。

## 用变动数据做模拟

这一小节主要通过多个例子(Queue、Map、模拟电路)讲解了如何使用可变数据来实现模拟。

大部分中国大学生，都是先从类C语言中学起的。对于状态的概念，我们并不陌生。所以这里不细讲。

主要提下共享和相等的概念。

熟悉JS的都知道JS有== 和=== 操作符，来区分相等和共享的概念，其中的坑不少。Java中==操作符也是判断共享的。

这个无奈之举在很多语言中都存在。

其中共享的概念更加值得关心。一旦遇到了并发/行的情况下。共享或者说状态所带来的隐患就像是一个诅咒，让多线程程序的编写需要谨小慎微的思索。关于并发的研究一直是一个计算机科学很重要的领域。有多种方法论:FP、CSP、Actor... 后面的章节主要讲解了一种常用的解决并发/行问题的方法 -- 串行化。

## 并发：时间是一个本质问题

如果我们思考为什么会存在并发问题，就会发现时间是本质问题。这导致对于共享的变量，如果采用了错误的事件发生顺序，我们的代码就会存在逻辑问题。

对此，我们的常见做法就是添加一些约束条件，让我们排除不正确的执行顺序。

一种是规定修改任意共享状态变量的两个操作都不允许同时存在。很显然，这是可行的，但是却是一个非常严厉的要求。

另一种是保证并发系统产生的结果与某种方式顺序产生出的结果完全一样。显然，这个限制比上一中要低些。

实际上，有时，我们可以用更低的限制，比如模拟宇宙的热量流动时，如果不考虑生物的存在，那么我们无论是什么样的顺序，最后所有对象都会得到一个固定的值，所谓的热寂。

那么有什么方式能实现限制呢？

一个常用的方式就是串行化即Serializable。其实可以类比Java中的Synchronized，或者加锁或信号量。

使用原子操作让我们能够取消一个操作中可能出现的时间分片。是更加轻量级的实现。

然而加锁带来的问题就是如果一个过程的实现需要使用多个锁，就可能会有死锁存在。

一个常见的死锁的解决方法就是给需要加锁的对象进行编号，让它根据合理顺序加锁。

然而即使如此，距离一个合理的并发编程的实践，还是远远不够。过段时间我会分享《J.U.C》的内容，到时再讨论下这个问题。

## 流

我们看到了状态导致了很多问题，那么有没有一种方案能够去不使用状态也能完成我们所需要的模块化和抽象的要求呢？

流就是另一种解决方案。

说流就不得不提到一个概念，惰性取值(Lazy Evaluation)，即延迟求值过程到实际需要时。

初看起来流似乎和列表很像，其实不然。流是惰性的表。如果你只想要取得1-100的表中的第2项。如果用表实现，那么你就必须完全构建出101个项的表再取值，而如果是使用流，你则只需要构造出第二项后直接返回，这样就避免了后面不需要的98项的计算。

不仅如此，流的概念能让你很好的构造无穷的序列，使用流，你相当于指明了剩余项可以取值的承诺(Promise)，而不是取值本身。因为流本身是一个如此优秀的概念，你完全可以很好的使用它。实际上，它在Python，ES6中也有相应的实现。Python2中的xrange，generator等，都是流的概念。有人提出了协程的概念来区别它和进程、线程。实际上，可以这样理解。

在Scheme中流的实现是使用过程嵌套来实现的。其类似于一个Python中包装器。

FP中正是使用了流的概念，来实现一个无状态的或者说状态无关的系统。

在另一方面，FP也有一些不适宜使用的场景。一个特别麻烦的领域出现在我们希望设计交互式系统的时候。

# 精选题解析

## 蒙特卡洛方法

以前听到说一个CS研究小组使用蒙特卡洛方法让计算机下国际象棋的获胜的几率增大了多少多少的新闻，然后就看了下蒙特卡洛方法。发现其实并没有这么悬浮。其实就是使用极大数定律，构建数量足够的测试样本得到频率做概率的方法。书中使用塞萨罗方法来求解pi的例子来讲解赋值带来的好处。

```
(define (estimate-pi trials)
  (sqrt (/ 6 (monte-carlo trials cesaro-test))))

(define (cesaro-test)
  (= (gcd (random 99999999) (random 999999999)) 1))

(define (monte-carlo trials expriment)
  (define (iter trials-remaining trials-passed)
    (cond ((= trials-remaining 0)
           (/ trials-passed trials))
          ((expriment)
           (iter (- trials-remaining 1) (+ trials-passed 1)))
          (else
           (iter (- trials-remaining 1) trials-passed))))
  (iter trials 0))

(estimate-pi 1000000)
```
这里我们可以把random方法当做是使用赋值实现的。

可以看到使用赋值来构建局部状态后，我们得以构造出相互独立的monte-carlo过程和cesaro-test过程。而如果不使用复制的话，我们则无法构造出如此内聚良好的过程。

## 队列

书中通过队列和字典的例子讲解了如何使用复制来模拟所需要的模型。

这里只讲解队列的实现。

按照意愿我们首先明确我们需要的过程。

```
(define (front-ptr queue) (car queue))

(define (rear-ptr queue) (cdr queue))

(define (set-front-ptr! queue item) (set-car! queue item))

(define (set-rear-ptr! queue item) (set-cdr! queue item))

(define (empty-queue? queue) (null? (front-ptr queue)))

(define (make-queue) (cons '() '()))
```
注意这里使用了set-car!和set-cdr!过程进行实现。

然后我们实现push和pop操作

```
(define (insert-queue! queue item)
  (let ((new-pair (cons item '())))
    (define (ins)
    ((set-front-ptr! queue new-pair)
          (set-rear-ptr! queue new-pair)
          queue))
    (define (dis)
    (set-cdr! (rear-ptr queue) new-pair)
           (set-rear-ptr! queue new-pair)
           queue)
    (if (empty-queue? queue)
          (ins)
          (dis))))
           
(define (delete-queue! queue)
  (cond ((empty-queue? queue)
         (error "DELETE! called with an empty queue" queue))
        (else
         (set-front-ptr! queue (cdr (front-ptr queue)))
         (queue))))
```
可以看到，我们的队列实现因为赋值的使用而变得很清晰，那你能构建出不使用赋值的版本么？
你能试着实现栈么？双向队列呢？

## 流化版本斐波那契数列

这个例子主要关心流的实现。

我们观察斐波那契数列，其实可以将其看为两个流的相加。

所以我们首先实现两个流相加的过程。

```
(define (add-streams s1 s2)
  (stream-map + s1 s2))
```

然后再利用add-streams过程进行构造。

```
(define fibs
  (stream-cons 0
               (stream-cons 1
                            (add-streams (stream-cdr fibs)
                                         (fibs)))))

```

这里巧妙地使用了流按需求值的特性。很明显，这样的构造非常的表意化。

# 后记

这次笔记没有习题部分的解析。所以，Do it Yourself吧。

回顾我学《SICP》的过程，断断续续大概花了9天左右的时间。其实并不算快，不过，像这种经典书籍就是要去花时间琢磨、推敲的，急不得。因为我以前了解过些许FP的概念，对于书中的一些东西，就没有第一次接触这些概念这么惊讶了。

不过至少在我看来，《SICP》是一本当之无愧的经典。如果用来当做学习编程的第一本书，或许我在大一学习的时候，就不会纠结于语言本身了。《SICP》告诉我们，编程中重要的是什么，为什么语言本身只是工具？如果我们要构建一个软件，我们思维上的工具又应该是什么？它们存在的根本原因是为了解决什么问题？它们的构造是否是黑科技？(实际上书中的一些基本过程，基本都给与了构建的思路，或者在联系中提及到了)。也让我明白了，为什么CS本身是错的。Computer Science is not science.它更加像一个工程。

真诚地感谢他们。是他们让我打开了编程的一道窗。

当然，《SICP》是本好书，但不要不思考就盲目接受，盲目使用。这样的话，《SICP》和谭浩强的书有什么差别？

最后，附上书中的前言，希望或许有志于此的在做的你，能共同努力前进。


{% cq %}我认为，在计算机科学中保持计算中的趣味性是特别重要的事情。这一学科在起步时饱含着趣味性。当然，那些付钱的客户们时常觉得受了骗。一段时间过后，我们开始严肃地看待他们的抱怨。我们开始意识到，自己真的像是要负起成功地、无差别的、完美地使用这些机器的责任。我不认为我们可以做到这些。我认为我们的责任是去拓展这个领域，将其发展到新的方向，并在自己的家里保持趣味性。我希望计算机科学的领域绝不要是去其趣味意思。**最重要的是，我希望我们不要变成传道士，不要认为你是兜售圣经的人，世界上这种人已经太多了。你所知道的有关计算的东西，其他人也能学得到。绝不要似乎成功计算的钥匙就掌握在你的手里。你所掌握的，也就是我认为并希望的，也就是智慧:那种看到这一机器比你第一次站在它面前时能做得更多的能力，这样你才能将它向前推进。**{% endcq %}