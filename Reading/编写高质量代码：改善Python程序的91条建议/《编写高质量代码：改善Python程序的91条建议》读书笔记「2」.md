title: 《编写高质量代码：改善Python程序的91条建议》读书笔记「2」
tag: [Python, 代码, 读书, 笔记]
category: 读书
------

# 前言

我最近一直在控制自己的发文速度。我希望成为一个优秀的工程师，而不是Blog写手。

# 正文

## 基础语法

### 记住函数传参既不是传值也不是传引用

对于Python函数参数是传值还是传引用这个问题的答案是：都不是。正确的叫法应该是传对象（call by object）或者说传对象的引用（call-by-object-reference）。函数参数在传递的过程中将整个对象传入，对可变对象的修改在函数外部以及内部都可见，调用者和被调用者之间共享这个对象，而对于不可变对象，由于并不能真正被修改，因此，修改往往是通过生成一个新对象然后赋值来实现的。

### 警惕默认参数潜在的问题

def在Python中是一个可执行的语句，当解释器执行def的时候，默认参数也会被计算，并存在函数的.func_defaults属性中。

如果不想让默认参数所指向的对象在所有的函数调用中被共享，而是在函数调用的过程中动态生成，可以在定义的时候使用None对象作为占位符。

### 慎用变长参数

使用\*args来实现可变参数列表：\*args用于接受一个包装为元组形式的参数列表来传递非关键字参数，参数个数可以任意。

使用**kwargs接受字典形式的关键字参数列表，其中字典的键值对分别表示不可变参数的参数名和值。如下例中apple表示参数名，而fruit为其对应的value，可以是一个或者多个键值对。

为什么要慎用可变长度参数呢？原因如下：

1. 使用过于灵活。
2. 如果一个函数的参数列表很长，虽然可以通过使用\*args和**kwargs来简化函数的定义，但通常这意味着这个函数可以有更好的实现方式，应该被重构。
3. 可变长参数适合在下列情况下使用:
	- 为函数添加一个装饰器。
	- 如果参数的数目不确定，可以考虑使用变长参数。
	- 用来实现函数的多态或者在继承情况下子类需要调用父类的某些方法的时候。

### 深入理解str()和repr()的区别

- 两者之间的目标不同：str()主要面向用户，其目的是可读性，返回形式为用户友好性和可读性都较强的字符串类型；而repr()面向的是Python解释器，或者说开发人员，其目的是准确性，其返回值表示Python解释器内部的含义，常作为编程人员debug用途。
- 在解释器中直接输入a时默认调用repr()函数，而print a则调用str()函数。
- repr()的返回值一般可以用eval()函数来还原对象，通常来说有如下等式。obj == eval(repr(obj))
- 这两个方法分别调用内建的\_\_str\_\_()和__repr\_\_()方法，一般来说在类中都应该定义__repr\_\_()方法，而\_\_str\_\_()方法则为可选，当可读性比准确性更为重要的时候应该考虑定义\_\_str\_\_()方法。如果类中没有定义\_\_str\_\_()方法，则默认会使用\_\_repr\_\_()方法的结果来返回对象的字符串表示形式。用户实现\_\_repr\_\_()方法的时候最好保证其返回值可以用eval()方法使对象重新还原。

### 分清staticmethod和classmethod的适用场景

Python中的静态方法（staticmethod）和类方法（classmethod）都依赖于装饰器（decorator）来实现。

其中静态方法的用法如下：

```
class C(object):    
	@staticmethod    
	def f(arg1, arg2, ...):
```

而类方法的用法如下：

```
class C(object):    
	@classmethod    
	def f(cls, arg1, arg2, ...):
```

静态方法和类方法都可以通过类名.方法名（如C.f()）或者实例.方法名（C().f()）的形式来访问。其中静态方法没有常规方法的特殊行为，如绑定、非绑定、隐式参数等规则，而类方法的调用使用类本身作为其隐含参数，但调用本身并不需要显示提供该参数。


那么应该将其声明为静态方法还是类方法呢？答案是两者都可，甚至将其作为一个定义在类的外部的函数都是可以的。但仔细分析该方法会发现它既不跟特定的实例相关也不跟特定的类相关，因此将其定义为静态方法是个不错的选择，这样代码能够一目了然。也许你会问：为什么不将该方法定义成外部函数呢？这是因为静态方法定义在类中，较之外部函数，能够更加有效地将代码组织起来，从而使相关代码的垂直距离更近，提高代码的可维护性。当然，如果有一组独立的方法，将其定义在一个模块中，通过模块来访问这些方法也是一个不错的选择。

## 库

### 掌握字符串的基本用法

判断一个变量s是不是字符串应使用isinstance(s,basestring)。

推荐了builtin库。。。

### 按需选择sort()或者sorted()

新手问题，不说。

### 使用copy模块深拷贝对象

新手问题，同上。

### 使用Counter进行计数统计

新手问题，同上。

### 深入掌握Config-Parser

自己看库。。。

### 使用argparse处理命令行参数

然而安利了docopt。


### 使用pandas处理大型CSV文件

自己看库。。。

### 一般情况使用Ele-mentTree解析XML

自己看库。。。

### 理解模块pickle优劣

自己理解。。。

### 序列化的另一个不错的选择——JSON

。。。

### 使用traceback获取栈信息

你懂的。。。

### 使用logging记录日志信息

还有人没用么。。。

### 使用threading模块编写多线程程序

。。。

### 使用Queue使多线程编程更安全

## 设计模式

### 利用模块实现单例模式

模块采用的其实是天然的单例的实现方式。

- 所有的变量都会绑定到模块。
- 模块只初始化一次。
- import机制是线程安全的（保证了在并发状态下模块也只有一个实例）。

所以用模块机制吧。。。

Alex Martelli认为单例模式要求“实例的唯一性”本身是有问题的，实际更值得关注的是实例的状态，只要所有的实例共享状态（可以狭义地理解为属性）、行为（可以狭义地理解为方法）一致就可以了。在这一思想的进一步指导下，他提出了Borg模式（在C#中又称为Monostate模式）。

通过Borg模式，可以创建任意数量的实例，但因为它们共享状态，从而保证了行为一致。虽然Alex的这个Borg模式仅适用于古典类（classicclasess），Python 2.2版本以后的新式类（new-style classes）需要使用__getattr__和__setattr__方法来实现（代码略），但其可开阔眼界。

### 用mixin模式让程序更加灵活

模板方法模式在C++或其他语言中并无不妥，但是在Python语言中，则颇有点画蛇添足的味道。

每个类都有一个__bases__属性，它是一个元组，用来存放所有的基类。与其他静态语言不同，Python语言中的基类在运行中可以动态改变。所以当我们向其中增加新的基类时，这个类就拥有了新的方法，也就是所谓的混入（mixin）。这种动态性的好处在于代码获得了更丰富的扩展功能。想象一下，你之前写好的代码并不需要个性，只要后期为它增加基类，就能够增强功能（或替换原有行为），这多么方便！值得进一步探索的是，利用反射技术，甚至不需要修改代码。

### 用发布订阅模式实现松耦合

发布订阅模式（publish/subscribe或pub/sub）是一种编程模式，消息的发送者（发布者）不会发送其消息给特定的接收者（订阅者），而是将发布的消息分为不同的类别直接发布，并不关注订阅者是谁。而订阅者可以对一个或多个类别感兴趣，且只接收感兴趣的消息，并且不关注是哪个发布者发布的消息。这种发布者和订阅者的解耦可以允许更好的可扩放性和更为动态的网络拓扑，故受到了大家的喜爱。

发布订阅模式的优点是发布者与订阅者松散的耦合，双方不需要知道对方的存在。


blinker已经被用在了多个广受欢迎的项目上，比如flask和django；而python-message则支持更多丰富的特性。

python-message利用回调函数的返回值来实现取消消息传递，非常巧妙（读者可以思考一下为什么能够利用回调函数的返回值）。

python-message是同步调用回调函数的，也就是说谁先sub谁就先被调用。大部分情况下这样已经能够满足大分需求，但有时需要后sub的函数先被调用，这时message.sub函数通过一个默认参数来支持的，只需要简单地在调用sub的时候加上front=True，这个回调函数将被插到所有之前已经sub的回调函数之前：sub('greet',hello,front=True)。

订阅/发布模式是观察者模式的超集，它不关注消息是谁发布的，也不关注消息由谁处理。但有时候我们也希望某个自己的类的也能够更方便地订阅/发布消息，也就是想退化为观察者模式，python-message同样提供了支持。

### 用状态模式美化代码

所谓状态模式，就是当一个对象的内在状态改变时允许改变其行为，但这个对象看起来像是改变了其类。状态模式主要用于控制一个对象状态的条件表达式过于复杂的情况，其可把状态的判断逻辑转移到表示不同状态的一系列类中，进而把复杂的判断逻辑简化。

得益于Python语言的动态性，状态模式的Python实现与C++等语言的版本比起来简单得多。

```
def workday():       
	print 'work hard!'
	def weekend():
	print 'play harder!'
	class People(object):
		passpeople = People()
			while True:      
				for i in xrange(1, 8):            
					if i == 6:                  
						people.day = weekend            
					if i == 1:                  
						people.day = workday            
					people.day()
```

运行上述代码，输出如下：

```
work hard!
work hard!
work hard!
work hard!
work hard!
play harder!
play harder!
......
```

就这样，通过在不同的条件下将实例的方法（即行为）替换掉，就实现了状态模式。但是这个简单的例子仍然有以下缺陷：

- 查询对象的当前状态很麻烦。
- 状态切换时需要对原状态做一些清扫工作，而对新的状态需要做一些初始化工作，因为每个状态需要做的事情不同，全部写在切换状态的代码中必然重复，所以需要一个机制来简化。

python-state包通过几个辅助函数和修饰函数很好地解决了这个问题，并且定义了一个简明状态机框架。

然后用它改写之前的例子。

```
@stateful
class People(object):      
	class Workday(State):            
		default = True            
		@behavior            
		def day(self):                   
			print 'work hard.'      
	class Weekend(State):             
		@behavior             
		def day(self):                   
			print 'play harder!'
people = People()
while True:      
	for i in xrange(1, 8):            
		if i == 6:                  
			switch(people, People.Weekend)            
		if i == 1:                  
			switch(people, People.Workday)            
		people.day()
```

首先是@stateful这个修饰函数，它包含了许多“黑魔法”，其中最重要的是重载了被修饰类的\_\_getattr\_\_()方法从而使得People的实例能够调用当前状态类的方法。被@stateful修饰后的类的实例是带有状态的，能够使用curr()查询当前状态，也可以使用switch()进行状态切换。接下来继续往下看，可以看到类Workday继续自State类，这个State类也是来自于state包，从其派生的子类能够使用\_\_begin\_\_和\_\_end\_\_状态转换协议，通过重载这两个协议，子类能够自定义进入和离开当前状态时对宿主（在本例中即people）的初始化和清理工作。对于一个@stateful类而言，有一个默认的状态（即其实例初始化后的第一个状态），通过类定义的default属性标识，default设置为True的类成为默认状态。@behavior修饰函数用以修饰状态类的方法，其实它是内置函数staticmethod的别名。为什么要将状态类的方法实现为静态方法呢？因为state包的原则是状态类只有行为，没有状态（状态都保存在宿主上），这样可以更好地实现代码重用。那么day()方法既然是静态的，为什么有self参数？这其实是因为self并不是Python的关键字，在这里使用self有助于理解状态类的宿主是People的实例。

可以看到，通过状态模式，可以像decorator一样去掉if…raise…上下文判断，但比它更棒的是真的一个if…raise…都没有了。

## 内部机制

### 理解built-in objects

我们知道Python中一切皆对象：字符是对象，列表是对象，内建类型（built-in type）也是对象；用户定义的类型是对象，object是对象，type也是对象。自Python2.2之后，为了弥补内建类型和古典类（classic classes）之间的鸿沟引入了新式类（new-style classes）。在新式类中，object是所有内建类型的基类，用户所定义的类可以继承自ob-ject也可继承自内建类型。


差别：

- object和古典类没有基类，type的基类为object。
- 新式类中type()的值和__class__的值是一样的，但古典类中实例的type为instance，其type()的值和__class__的值不一样。
- 继承自内建类型的用户类的实例[6]也是ob-ject的实例，object是type的实例，type实际是个元类（metaclass）。
- object和内建类型以及所有基于type构建的用户类都是type的实例。
- 在古典类中，所有用户定义的类的类型都为instance。

应当通过元类的类型来确定类的类型：古典类的元类为types.ClassType，新式类的元类为type类。

新式类相对于古典类来说有很多优势：能够基于内建类型构建新的用户类型，支持property和描述符特性等。作为新式类的祖先，Object类中还定义了一些特殊方法，如：\_\_new\_\_()，\_\_init\_\_()，\_\_delattr\_\_()，\_\_getattribute\_\_()，\_setattr\_\_()，\_\_hash\_\_()，\_\_repr\_\_()，\_\_str\_\_()等。

### \_\_init\_\_()不是构造方法


很多Pythoner会有这样的误解，认为\_\_init\_\_()方法是类的构造方法。因为从表面上看它确实很像构造方法：当需要实例化一个对象的时候，使用a=Class(args...)便可以返回一个类的实例，其中args的参数与\_\_init\_\_()方法中申明的参数一样。可是事实真相是怎样的呢？

实际上\_\_init\_\_()并不是真正意义上的构造方法，\_\_init\_\_()方法所做的工作是在类的对象创建好之后进行变量的初始化。\_\_new\_\_()方法才会真正创建实例，是类的构造方法。这两个方法都是object类中默认的方法，继承自object的新式类，如果不覆盖这两个方法将会默认调用object中对应的方法。

一般情况下不需要覆盖\_\_new\_\_()方法，但当子类继承自不可变类型，如str、int、unicode或者tuple的时候，往往需要覆盖该方法。

当需要控制实例创建的时候可使用\_\_new\_\_()方法，而控制实例初始化的时候使用\_\_init
_\_()方法。

那么在什么特殊情况下需要覆盖__new__()方法呢？有以下几种情况：

1. 当类继承（如str、int、unicode、tuple或者forzenset等）不可变类型且默认的\_\_new\_\_()方法不能满足需求的时候。
2. 用来实现工厂模式或者单例模式或者进行元类编程（元类编程中常常需要使用\_\_new\_\_()来控制对象创建。
3. 作为用来初始化的\_\_init\_\_()方法在多继承的情况下，子类的\_\_init\_\_()方法如果不显式调用父类的\_\_init\_\_()方法，则父类的\_\_init\_\_()方法不会被调用。

### 理解名字查找机制

Python中所有的变量名都是在赋值的时候生成的，而对任何变量名的创建、查找或者改变都会在命名空间（namespace）中进行。变量名所在的命名空间直接决定了其能访问到的范围，即变量的作用域。Python中的作用域自Python2.2之后分为局部作用域（local）、全局作用域（Global）、嵌套作用域（enclosing functions locals）以及内置作用域（Build-in）这4种。

- **局部作用域**：一般来说函数的每次调用都会创建一个新的本地作用域，拥有新的命名空间。因此函数内的变量名可以与函数外的其他变量名相同，由于其命名空间不同，并不会产生冲突。默认情况下函数内部任意的赋值操作（包括=语句、import语句、def语句、参数传递等）所定义的变量名，如果没用global语句，则申明都为局部变量，即仅在该函数内可见。
- **全局作用域**：定义在Python模块文件中的变量名拥有全局作用域，需要注意的是这里的全局仅限单个文件，即在一个文件的顶层的变量名仅在这个文件内可见，并非所有的文件，其他文件中想使用这些变量名必须先导入文件对应的模块。当在函数之外给一个变量名赋值时是在其全局作用域的情况下进行的。
- **嵌套作用域**：一般在多重函数嵌套的情况下才会考虑到。需要注意的是global语句仅针对全局变量，在嵌套作用域的情况下，如果想在嵌套的函数内修改外层函数中定义的变量，即使使用global进行申明也不能达到目的，其结果最终是在嵌套的函数所在的命名空间中创建了一个新的变量。
- **内置作用域**：这个相对简单，它是通过一个标准库中名为__builtin__的模块来实现的。

查找顺序遵循变量解析机制LEGB法则，即依次搜索4个作用域：局部作用域、嵌套作用域、全局作用域以及内置作用域，并在第一个找到的地方停止搜寻，如果没有搜到，则会抛出异常。因此当存在多个同名变量的时候，操作生效的往往是搜索顺序在前的。

### 为什么需要self参数

self想必大家都不陌生，在类中当定义实例方法的时候需要将第一个参数显式声明为self，而调用的时候并不需要传入该参数。

也许很多人感受self最奇怪的地方就是：在方法声明的时候需要定义self作为第一个参数，而调用方法的时候却不用传入这个参数。虽然这并不影响语言本身的使用，而且也很容易遵循这个规则，但多多少少会在心里问一问：既然这样，为什么必须在定义方法的时候声明self参数呢？去掉第一个参数self不是更简洁吗？就如C++中的this指针一样。我们来简单探讨一下为什么需要self。

- Python在当初设计的时候借鉴了其他语言的一些特征，如Moudla-3中方法会显式地在参数列表中传入self。
- Python语言本身的动态性决定了使用self能够带来一定便利。
- 在存在同名的局部变量以及实例变量的情况下使用self使得实例变量更容易被区分。

### 理解MRO与多继承

在古典类中，MRO搜索采用简单的自左至右的深度优先方法，即按照多继承申明的顺序形成继承树结构，自顶向下采用深度优先的搜索顺序，当找到所需要的属性或者方法的时候就停止搜索。

新式类采用的是C3 MRO搜索方法，该算法描述如下：

假定，C1C2...CN表示类C1到CN的序列，其中序列头部元素(head)=C1，序列尾部(tail)定义为=C2..CN；C继承的基类自左向右分别表示为B1，B2...BN；L[C]表示C的线性继承关系，其中L[ob-ject]=object。

算法具体过程如下：L[C(B1 ... BN)] = C + merge(L[B1] ... L[BN], B1 ... BN)其中merge方法的计算规则如下：在L[B1]...L[BN],B1...BN中，取L[B1]的head，如果该元素不在L[B2]...L[BN],B1...BN的尾部序列中，则添加该元素到C的线性继承序列中，同时将该元素从所有列表中删除（该头元素也叫good head），否则取L[B2]的head。继续相同的判断，直到整个列表为空或者没有办法找到任何符合要求的头元素（此时将引发一个异常）。

关于MRO的搜索顺序我们也可以在新式类中通过查看__mro__属性得到证实。

实际上MRO虽然叫方法解析顺序，但它不仅是针对方法搜索，对于类中的数据属性也适用。读者可以自行验证。

### 理解描述符机制

除了在不同的局部变量、全局变量中查找名字，还有一个相似的场景不可不察，那就是查找对象的属性。在Python中，一切皆是对象，所以类也是对象，类的实例也是对象。

每一个类都有一个__dict__属性，其中包含的是它的所有属性，又称为类属性。留意类属性的最后一个元素，可以看到我们代码中定义的属性在其中的体现。

除了与类相关的类属性之外，每一个实例也有相应的属性表（__dict__），称为实例属性。当我们通过实例访问一个属性时，它首先会尝试在实例属性中查找，如果找不到，则会到类属性中查找。

能不能给类增加一个属性呢？答案是，能，也不能。说能，是因为每一个class也是一个对象，动态地增减对象的属性与方法正是Python这种动态语言的特性，自然是支持的。

说不能，是因为在Python中，内置类型和用户定义的类型是有分别的，内置类型并不能够随意地为它增加属性或方法。

当我们通过“.”操作符访问一个属性时，如果访问的是实例属性，与直接通过__dict__属性获取相应的元素是一样的；而如果访问的是类属性，则并不相同：“.”操作符封装了对两种不同属性进行查找的细节。

不过，这里要讲的并不止于此，“.”操作符封装了对实例属性和类属性查找的细节，只讲了一半事实，还有一部分隐而未谈，那就是描述符机制。

当通过“.”操作符访问时，Python的名字查找并不是之前说的先在实例属性中查找，然后再在类属性中查找那么简单，实际上，根据通过实例访问属性和根据类访问属性的不同，有以下两种情况：

一种是通过实例访问，比如代码obj.x，如果x是一个描述符，那么\_\_getattribute\_\_()会返回type(obj).\_\_dict\_\_['x'].\_\_get\_\_(obj,type(obj))结果，即：type(obj)获取obj的类型；type(obj).\_\_dict\_\_['x']返回的是一个描述符，这里有一个试探和判断的过程；最后调用这个描述符的\_\_get\_\_()方法。另一种是通过类访问的情况，比如代码cls.x，则会被\_\_getattribute\_\_()转换为cls.\_\_dict\_\_['x'].\_\_get\_\_(None,cls)。

### 区别\_\_getattr\_\_()和\_\_getattribute\_\_()方法

\_\_getattr\_\_()和\_\_getattribute\_\_()都可以用做实例属性的获取和拦截（注意，仅对实例属性（in-stance variable）有效，非类属性），\_\_getattr\_\_()适用于未定义的属性，即该属性在实例中以及对应的类的基类以及祖先类中都不存在，而\_\_getat-tribute\_\_()对于所有属性的访问都会调用该方法。

需要注意的是__getattribute__()仅应用于新式类。

当访问一个不存在的实例属性的时候就会抛出AttributeError异常。这个异常是由内部方法\_\_getattribute\_\_(self,name)抛出的，因为\_\_getattribute\_\_()会被无条件调用，也就是说只要涉及实例属性的访问就会调用该方法，它要么返回实际的值，要么抛出异常。Python的文档http://docs.python.org/2/reference/data-model.html#object.getattribute中也提到了这一点。那么\_\_getattr\_\_()会在什么情况下调用呢？

实际上\_getattr\_\_()方法仅如下情况下才被调用：属性不在实例的\_\_dict\_\_中；属性不在其基类以及祖先类的__dict__中；触发AttributeError异常时（注意，不仅仅是\_\_getat-tribute\_\_()引发的AttributeError异常，property中定义的get()方法抛出异常的时候也会调用该方法）。需要特别注意的是当这两个方法同时被定义的时候，要么在\_\_getattribute\_\_()中显式调用，要么触发AttributeError异常，否则\_\_getattr\_\_()永远不会被调用。\_\_getattribute\_\_()及\_\_getattr\_\_()方法都是Object类中定义的默认方法，当用户需要覆盖这些方法时有以下几点注意事项：

- 避免无穷递归。
- 访问未定义的属性。

另外关于\_\_getattr\_\_()和\_\_getattribute\_\_()有以下两点提醒：

- 覆盖了\_\_getattribute\_\_()方法之后，任何属性的访问都会调用用户定义的\_\_getattribute\_\_()方法，性能上会有所损耗，比使用默认的方法要慢。
- 覆盖的\_\_getattr\_\_()方法如果能够动态处理事先未定义的属性，可以更好地实现数据隐藏。