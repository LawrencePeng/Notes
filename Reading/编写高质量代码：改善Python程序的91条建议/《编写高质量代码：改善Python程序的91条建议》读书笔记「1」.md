title: 《编写高质量代码：改善Python程序的91条建议》读书笔记「1」
tag: [Python, 代码, 读书, 笔记]
category: 读书

------

如果你稍微了解过Python社区的人嘴里经常吐出的一些概念，那么你就很可能听过这么一个词：Pythonic。

如果写出高质量的，像Python老鸟写出来的程序呢？如果你有这方面的需求，那么这次的读书笔记系列将满足你。

# 引论

## 理解Pythonic概念

The Zen of Python中有几点非常深入人心：

- 美胜丑，显胜隐，简胜杂，杂胜乱，平胜陡，疏胜密。
- 找到简单问题的一个方法，最好是唯一的方法（正确的解决之道）。
- 难以解释的实现，源自不好的主意；如有非常棒的主意，它的实现肯定易于解释。

我觉得把这个说成是Pythonic也不为过。

### Pythonic的定义

充分体现Python自身特色的代码风格。接下来就看看这样的代码风格在实际中是如何体现的。

### 代码风格

在语法上，代码风格要充分表现Python自身特色。例如利用装包/解包机制进行变量交换，使用with语句管理关闭文件描述符的操作。

Pythonic的一个要求，就是对Python语法本身的充分发挥，写出来的代码带着Python味儿，而不是看着像C语言代码，或者Java代码。

应当追求的是充分利用Python语法，但不应当过分地使用奇技淫巧。让代码更加易读是衡量的一个标准。

### 标准库

写Pythonic程序需要对标准库有充分的理解，特别是内置函数和内置数据类型。

### Pythonic的库或框架

编写应用程序的时候的要求会更高一些。因为编写应用程序一般需要团队合作，那么可能你编写的那一部分正好是团队的另一成员需要调用的接口，换言之，你可能正在编写库或框架。

程序员利用Pythonic的库或框架能更加容易、更加自然地完成任务。

如果用Python编写的库或框架迫使程序员编写累赘的或不推荐的代码，那么可以说它并不Pythonic。

一个Pythonic的框架不会对已经通过惯用法完成的东西重复发明“轮子”，而且它也遵循常用的Python惯例。

创建Pythonic的框架极其困难，什么理念更酷、更符合语言习惯对此毫无帮助，事实上这些年来优秀的Python代码的特性也在不断演化。

## 编写Pythonic代码

### 要避免劣化代码

与优化代码对应，劣化代码就是一开始写出来就是不合理的代码，比如不合适的变量命名等。

#### 避免只用大小写来区分不同的对象

#### 避免使用容易引起混淆的名称

#### 不要害怕过长的变量名

### 深入认识Python有助于编写Pythonic代码

可以从以下几个方面进行着手：

- 全面掌握Python提供给我们的所有特性，包括语言特性和库特性。其中最好的学习方式应该是通读官方手册中的Language Refer-ence和Library Reference。掌握了语言特性和库特性，以后许多“惯用法”自然而然就掌握了，写代码的时候，自然会使用常见的、公认的、简短的惯用法来实现预期效果，也使得代码显得尤为Pythonic。
- 随着Python的版本更新、时间的推移，Python语言不断演进，社区不断成长，还需要学习每个Python新版本提供的新特性，以及掌握它的变化趋势。从另一角度来看，一方面Python语言推荐使用大量的惯用法来完成任务（“完成任务的唯一方法”）；另一方面，社区不断演变的新惯用法反过来又影响了语言的进化，以更好地支持惯用法。比如早年的Pythonista常用dict.has_key()方法来判断字典对象是否包含某个元素，但新版本的Python中提供了in操作符（支持多种容器类型）取代它。改变习惯的阻力很大，而克服这些阻力的唯一方法就是加深对Python的认识，因为在语言支持正确的惯用法之后，非推荐的代码通常执行起来更慢。所以说，不更新知识是不行的。
- 深入学习业界公认的比较Pythonic的代码，比如Flask、gevent和requests等。
- 最后，除了修炼内功外，也可以尝试利用工具达到事半功倍的效果。这里推荐了PEP8做风格检查程序。

其实Pythonic的代码，往往是放弃自我风格的代码，而要有“放弃自我风格”的觉悟，是非常困难、非常痛苦的。

要突破这种瓶颈，完成自我蜕变，除了需要付出许多精力去学习外，参考更好的书籍进行辅助也是相当有帮助的。目前市面上针对编写“高质量”的Python程序的方法的书籍并不多，本书应是一本比较好的参考资料。作为作者，我们也真心希望自己的一点点经验分享能够对读者有所帮助。

## 理解Python与C语言的不同之处

我们都知道，Python底层是用C语言实现的，但切忌用C语言的思维和风格来编写Python代码。

### “缩进”与“{}”

不语

### '与"

不语

### 三元操作符“?:”

python也有提供类似的语法： 
```
a if x else b
```

### switch...case

python语言同样也提供了替代方案：

1. if else语句
2. 跳转表 例如：

```
def f(x):
    return {
            0: "You typed zero.\n",                    
            1: "You are in top.\n",        
            2: "n is an even number\n"                    
            }.get(n,  "Only single-digit numbers are allowed\n")
```

事实上，其差异性远远不止这些。但总归一句话：不要被其他语言的思维和习惯困扰，掌握Python的哲学和思维方式才是硬道理。

## 在代码中适当添加注释

Python中有3种形式的代码注释：块注释、行注释以及文档注释（docstring）。

这3种形式的惯用法大概有如下几种：

1. 使用块或者行注释的时候仅仅注释那些复杂的操作、算法，还有可能别人难以理解的技巧或者不够一目了然的代码。
2. 注释和代码隔开一定的距离，同时在块注释之后最好多留几行空白再写代码。
3. 给外部可访问的函数和方法（无论是否简单）添加文档注释。注释要清楚地描述方法的功能，并对参数、返回值以及可能发生的异常进行说明，使得外部调用它的人员仅仅看docstring就能正确使用。较为复杂的内部方法也需要进行注释。
4. 推荐在文件头中包含copyright申明、模块描述等，如有必要，可以考虑加入作者信息以及变更记录。

至于如何写注释，请参照我以前博文。


## 通过适当添加空行使代码布局更为优雅、合理

布局清晰、整洁、优雅的代码能够给阅读它的人带来愉悦感，而且它能帮助开发者之间进行良好的沟通。在一个团队中，保持良好的代码格式需要团队成员在选取一套合适的代码格式规则的基础上遵从和应用。同时它需要每个团队成员树立正确的态度，因为实际工作中有很多开发者抱着这样的想法：“代码能工作才是最重要的”，但往往代码会不断修改，且可读性直接关系到可维护性和可扩展性。因此我们需要端正态度——“代码不是恒定的，只有风格才能延续，能工作的代码和整洁、优雅的格式同样重要”。

Python代码布局也有一些基本规则可以遵循：

1. 在一组代码表达完一个完整的思路之后，应该用空白行进行间隔。
2. 尽量保持上下文语义的易理解性。如当一个函数需要调用另一个函数的时候，尽量将它们放在一起，最好调用者在上，被调用者在下。
3. 避免过长的代码行，每行最好不要超过80个字符。
4. 不要为了保持水平对齐而使用多余的空格，其实使阅读者尽可能容易地理解代码所要表达的意义更重要。空格的使用要能够在需要强调的时候警示读者，在疏松关系的实体间起到分隔作用，而在具有紧密关系的时候不要使用空格。具体细节如下：
	- 二元运算符（赋值（=），比较（==，<，>，!=，<>，<=，>=，in，not in，is，is not）、布尔运算（and，or，not））的左右两边应该有空格，如x == 1。
	- 逗号和分号前不要使用空格。推荐: if x == 4: print x, y; x, y = y, x不推荐: if x == 4 : print x , y ; x , y = y , x
	- 函数名和左括号之间、序列索引操作时序列名和[ ]之间不需要空格，函数的默认参数两侧不需要空格。
	- 强调前面的操作符的时候使用空格，如 -2 -5（在-2和5之间的减号前后需要添加空格）、b * b + a * c（在加号前后需要添加空格）。

## 编写函数的4个原则

1. 函数设计要尽量短小，嵌套层次不宜过深。
2. 函数申明应该做到合理、简单、易于使用。
3. 　函数参数设计应该考虑向下兼容。实际工作中我们可能面临这样的情况：随着需求的变更和版本的升级，在前一个版本中设计的函数可能需要进行一定的修改才能满足这个版本的要求。因此在设计过程中除了着眼当前的需求还得考虑向下兼容。
4. 一个函数只做一件事，尽量保证函数语句粒度的一致性。

Python中函数设计的好习惯还包括：不要在函数中定义可变对象作为默认值，使用异常替换返回错误，保证通过单元测试等。

## 将常量集中到一个文件

在Python中应该如何使用常量呢？一般来说有以下两种方式：

1. 通过命名风格来提醒使用者该变量代表的意义为常量，如常量名所有字母大写，用下划线连接各个单词，如MAX_OVERFLOW、TO-TAL。然而这种方式并没有实现真正的常量，其对应的值仍然可以改变，这只是一种约定俗成的风格。
2. 通过自定义的类实现常量功能。这要求符合“命名全部为大写”和“值一旦绑定便不可再修改”这两个条件。

无论采用哪一种方式来实现常量，都提倡将常量集中到一个文件中，因为这样有利于维护，一旦需要修改常量的值，可以集中统一进行而不是逐个文件去检查。

# 编程惯用法

## 利用assert语句来发现问题

断言（assert）在很多语言中都存在，它主要为调试程序服务，能够快速方便地检查程序的异常或者发现不恰当的输入等，可防止意想不到的情况出现。

断言是有代价的，它会对性能产生一定的影响，对于编译型的语言，如C/C++，这也许并不那么重要，因为断言只在调试模式下启用。但Python并没有严格定义调试和发布模式之间的区别，通常禁用断言的方法是在运行脚本的时候加上-O标志，这种方式带来的影响是它并不优化字节码，而是忽略与断言相关的语句。

断言实际是被设计用来捕获用户所定义的约束的，而不是用来捕获程序本身错误的，因此使用断言需要注意以下几点：

1. 不要滥用，这是使用断言最基本的原则。若由于断言引发了异常，通常代表程序中存在bug。因此断言应该使用在正常逻辑不可到达的地方或正常情况下总是为真的场合。
2. 如果Python本身的异常能够处理就不要再使用断言。如对于类似于数组越界、类型不匹配、除数为0之类的错误，不建议使用断言来进行处理。
3. 不要使用断言来检查用户的输入。
4. 在函数调用后，当需要确认返回值是否合理时可以使用断言。
5. 当条件是业务逻辑继续下去的先决条件时可以使用断言。

## 数据交换值的时候不推荐使用中间变量

这个估计不需要怎么说，pythonic的方式不仅效率更高，可读性也更好。

## 充分利用Lazy evalu-ation的特性

Lazy evaluation常被译为“延迟计算”或“惰性计算”，指的是仅仅在真正需要执行的时候才计算表达式的值。充分利用Lazy evaluation的特性带来的好处主要体现在以下两个方面：

1. 避免不必要的计算，带来性能上的提升。
2. 节省空间，使得无限循环的数据结构成为可能。

这节可以看我的《SICP》读书笔记系列加深理解。

## 理解枚举替代实现的缺陷

Python以前没有提供枚举机制，所以很多人用各种方式Hack了，包括使用

1. 类属性 
	
	```
	class Seasons:
		Spring, Summer, Autumn, Winter = range(4)
	```
2. 函数

	```
	def enum(*posarg, **keysarg):     
	return type("Enum", 
	(object,),
	dict(zip(posarg, xrange(len(posarg))),
	**keysarg))
	```
	
3. 使用collections.namedtuple

	```
	Seasons = namedtuple('Seasons','Spring Summer Autumn Winter')._make(range(4))
	```

但是它们的缺陷也很明显：

1. 允许枚举值重复。
2. 支持无意义操作。

实际上Python2.7以后的版本还有另外一种替代选择——使用第三方模块flufl.enum，它包含两种枚举类：一种是Enum，只要保证枚举值唯一即可，对值的类型没限制；还有一种是IntEnum，其枚举值为int型。

Python3.4中根据PEP435的建议终于加入了枚举Enum，其实现主要参考实现flufl.enum，但两者之间还是存在一些差别，如flufl.enum允许枚举继承，而Enum仅在父类没有任何枚举成员的时候才允许继承等。

如果要在Python3.4之前的版本中使用枚举Enum，可以安装Enum的向后兼容包enum34。

## 不推荐使用type进行类型检查

作为动态性的强类型脚本语言，Python中的变量在定义的时候并不会指明具体类型，Python解释器会在运行时自动进行类型检查并根据需要进行隐式类型转换。按照Python的理念，为了充分利用其动态性的特征是不推荐进行类型检查的。

type()函数并不是就意味着可以高枕无忧了，主张“不推荐使用type来进行变量类型检查”是有一定的缘由的。

1. 对于用户包装类的判断问题
2. 在古典类中，所有类的实例的type值都相等。

那么究竟应怎样来约束用户的输入类型从而使之与我们期望的类型一致呢？答案是：如果类型有对应的工厂函数，可以使用工厂函数对类型做相应转换，如list(listing)、str(name)等，否则可以使用isinstance()函数来检测，其原型如下：
	
	isinstance(object, classinfo)


## 尽量转换为浮点类型后再做除法

Python在最初的设计过程中借鉴了C语言的一些规则，比如选择C的long类型作为Python的整数类型，double作为浮点类型等。同时标准的算术运算，包括除法，返回值总是和操作数类型相同。

作为静态类型语言，C语言中这一规则问题不大，因为变量都会预先申明类型，当类型不符的时候，编译器也会尽可能进行强制类型转换，否则编译会报错。但Python作为一门高级动态语言并没有类型申明这一说，因此在上面的例子中你不能提前申明返回的计算结果为浮点数，当除法运算中两个操作数都为整数的时候，其返回值也为整数，运算结果将直接截断，从而在实际应用中造成潜在的质的误差。Python中除了除法运算之外，整数和浮点数的其他操作行为还是一致的，因此这容易让人产生一种误解，数值的计算与具体操作数的类型（整数还是浮点数）无关，但事实上对于整数除法这是编程过程中潜在的一个危险，因为当你编写一个函数时，即使你希望调用者传入的是浮点类型，但如果不在函数入口进行类型检查或者转换，就无法阻止函数调用者传递整数参数，而往往这种类型的错误还不容易发觉。因此推荐的做法之一是**当涉及除法运算的时候尽量先将操作数转换为浮点类型再做运算**。

当然随着Python语言的发展，对整数除法问题也做了一定的修正，在Python3中这个问题已经不存在了。Python3之前的版本可以通过from__future__ import division机制使整数除法不再截断，这样即使不进行浮点类型转换。

## 警惕eval()的安全漏洞

一句话： Eval() is evil.

使用eval不仅会带来性能问题，还存在安全问题。

因此在实际应用过程中**如果使用对象不是信任源，应该尽量避免使用eval，在需要使用eval的地方可用安全性更好的ast.lit-eral_eval替代。**

## 使用enumerate()获取序列迭代的索引和值

基本上所有的项目中都存在对序列进行迭代并获取序列中的元素进行处理的场景。这是一个非常普通而且简单的需求，相信很多人一口气能写出N种实现方法。

1. 在每次循环中对索引变量进行自增。
2. 使用range()和len方法结合。
3. 使用while循环，使用len获取循环次数。
4. 使用zip()方法。
5. 使用enumerate()方法。

这里推荐的是使用方法五，因为它代码清晰简洁，可读性最好。函数enumerate()是在Python2.3中引入的，主要是为了解决在循环中获取索引以及对应值的问题。它具有一定的惰性（lazy），每次仅在需要的时候才会产生一个(index,item)对。

需要提醒的是，对于字典的迭代循环，enu-merate()函数并不适合，虽然在使用上并不会提示错误，但输出的结果与期望的大相径庭，这是因为字典默认被转换成了序列进行处理。

## 分清==与is的适用场景

类似于Java的 ==和equals方法的区别。

is的作用是用来检查对象的标示符是否一致的，也就是比较两个对象在内存中是否拥有同一块内存空间，它并不适合用来判断两个字符串是否相等。x is y仅当x和y是同一个对象的时候才返回True，x is b 基本相当于id(x) == id(y)。而==才是用来检验两个对象的值是否相等的，它实际调用内部__eq__()方法，因此a == b相当于a.__eq__(b)，所以==操作符是可以被重载的，而is不能被重载。一般情况下，如果x is y为True的话x == y的值也为True（特殊情况除外，如NaN，a = float('NaN')；a is a 为True，a==a为false），反之则不然。

## 考虑兼容性，尽可能使用Unicode

Python内建的字符串有两种类型：str和Uni-code，它们拥有共同的祖先basestring。

Python3中默认为Unicode。

这点比较新手，不细讲。

## 构建合理的包层次来管理module

我们知道，本质上每一个Python文件都是一个模块，使用模块可以增强代码的可维护性和可重用性。但显然在大的项目中将所有的Python文件放在一个目录下并不是一个值得推荐的做法，我们需要合理地组织项目的层次来管理模块，这就是包（Package）发挥功效的地方了。

什么是包呢？简单说包即是目录，但与普通目录不同，它除了包含常规的Python文件（也就是模块）以外，还包含一个__init__.py文件，同时它允许嵌套。

包中的模块可以通过“.”访问符进行访问，即“包名.模块名”。

包中的模块同样可以被导入其他模块中。有以下几种导入方法：

1. 直接导入一个包
2. 导入子模块或子包，包嵌套的情况下可以进行嵌套导入

前面提到在包对应的目录下包含有__init__.py文件，那么这个文件的作用是什么呢？它最明显的作用就是使包和普通目录区分；其次可以在该文件中申明模块级别的import语句从而使其变成包级别可见。

如果要import包Package下Module1中的类Test，当__init__.py文件为空的时候需要使用完整的路径来申明im-port语句：from Package.Module1 import Test但如果在__init__.py文件中添加from Mod-ule1 import Test语句，则可以直接使用from Package import Test来导入类Test。

需要注意的是，如果__init__.py文件为空，当意图使用fromPackage import *将包Package中所有的模块导入当前名字空间时并不能使得导入的模块生效，这是因为不同平台间的文件的命名规则不同，Python解释器并不能正确判定模块在对应的平台该如何导入，因此它仅仅执行__init__.py文件，如果要控制模块的导入，则需要对__init__.py文件做修改。

__init__.py文件还有一个作用就是通过在该文件中定义__all__变量，控制需要导入的子包或者模块。

包的使用能够带来以下便利：

- **合理组织代码，便于维护和使用。**
- **能够有效地避免名称空间冲突**

# 基础语法

## 有节制地使用from...import语句

Python提供了3种方式来引入外部模块：im-port语句、from...import...及__import__函数。其中较为常见的为前面两种，而__import__函数与import语句类似，不同点在于前者显式地将模块的名称作为字符串传递并赋值给命名空间的变量。

在使用import的时候注意以下几点：

- 在使用import的时候注意以下几点：
- 有节制地使用from a import B形式，可以直接访问B。
- 尽量避免使用from a import *，因为这会污染命名空间，并且无法清晰地表示导入了哪些对象。

为什么在使用import的时候要注意以上几点呢？在回答这个问题之前先来简单了解一下Python的import机制。

Python在初始化运行环境的时候会预先加载一批内建模块到内存中，这些模块相关的信息被存放在sys.modules中。

读者导入sys模块后在Python解释器中输入sys.modules.items()便可显示所有预加载模块的相关信息。

当加载一个模块的时候，解释器实际上要完成以下动作：

- 在sys.modules中进行搜索看看该模块是否已经存在，如果存在，则将其导入到当前局部命名空间，加载结束。
- 如果在sys.modules中找不到对应模块的名称，则为需要导入的模块创建一个字典对象，并将该对象信息插入sys.modules中。
- 加载前确认是否需要对模块对应的文件进行编译，如果需要则先进行编译。
- 执行动态加载，在当前模块的命名空间中执行编译后的字节码，并将其中所有的对象放入模块对应的字典中。

需要注意的是，直接使用import和使用froma import B形式这两者之间存在一定的差异，后者直接将B暴露于当前局部空间，而将a加载到sys.modules集合。

了解完import机制，我们再来看看对于froma import ...无节制的使用会带来什么问题。

### 命名空间的冲突

### 循环嵌套导入的问题

## 优先使用absoluteimport来导入模块

解释器默认先从当前目录下搜索对应的模块。

在Python2.4以前默认为隐式的relative im-port，局部范围的模块将覆盖同名的全局范围的模块。

如果要使用标注库中同名的模块，你不得不去深入考察sys.modules一番，显然这并不是一种非常友好的做法。

Python2.5中后虽然默认的仍然是relative import，但它为absolute import提供了一种新的机制，在模块中使用from __future__ im-port absolute_import 语句进行说明后再进行导入。

同时它还通过点号提供了一种显式进行rela-tive import的方法，“.”表示当前目录，“..”表示当前目录的上一层目录。

相比于absolute import，relative import在实际应用中反馈的问题较多，因此推荐优先使用ab-solute import。

absolute import可读性和出现问题后的可跟踪性都更好。

当项目的包层次结构较为复杂的时候，显式relative import也是可以接受的，由于命名冲突的原因以及语义模糊等原因，不推荐使用隐式的relative import，并且它在Python3中已经被移除。

## i+=1不等于++i

++i并不被支持。

## 使用with自动关闭资源

对文件操作完成后应该立即关闭它们。

在文件处理时使用with的好处在于无论程序以何种方式跳出with块，总能保证文件被正确关闭。

需要实现__enter__()和__exit__(exception_type,exception_value,traceback)方法。

Python还提供了contextlib模块，该模块是通过Generator实现的，contextlib中的contextmanager作为装饰器来提供一种针对函数级别的上下文管理机制，可以直接作用于函数/对象而不用去关心__enter()__和__exit()__方法的具体实现。

这点比较常见，不语。

## 使用else子句简化循环（异常处理）

有其他编程语言经验的程序员接触到Python时，对于它无所不在的else往往感到非常惊讶。在Python中，不仅分支语句有else子句，而且循环语句也有，甚至连异常处理也有。

与C/C++等较为“老土”的语言相比，else子句使程序员的生产力和代码的可读性都得到了提高，所以建议大家多使用else，让程序变得更加Pythonic。

在Python中还有不少语法都是致力于让程序员可以编写更加简明、更接近自然语言语义的代码，比如in和with语句（将在其他章中讲述相关用法），这也证明充分地学习手册中的Language Reference非常有必要。

## 遵循异常处理的几点基本原则
Python中常用的异常处理语法是try、except、else、finally，它们可以有多种组合，如try-except（一个或多个），try -except-else；try -finally以及try -except-else-finally等。

异常处理通常需要遵循以下几点基本原则：

1. 注意异常的粒度，不推荐在try中放入过多的代码。
2. 谨慎使用单独的except语句处理所有异常，最好能定位具体的异常。
3. 注意异常捕获的顺序，在合适的层次处理异常。
4. 使用更为友好的异常信息，遵守异常参数的规范。

如果内建异常类不能满足需求，用户可以在继承内建异常的基础上针对特定的业务逻辑定义自己的异常类。但无论是内建异常类，还是用户定义的异常类，在传递异常参数的时候都需要遵守异常参数规范。

## 避免finally中可能发生的陷阱

使用finally时，也要特别小心一些陷阱。

当try块中发生异常的时候，如果在ex-cept语句中找不到对应的异常处理，异常将会被临时保存起来，当finally执行完毕的时候，临时保存的异常将会再次被抛出，但如果finally语句中产生了新的异常或者执行了return或者break语句，那么临时保存的异常将会被丢失，从而导致异常屏蔽。


## 深入理解None，正确判断对象是否为空

Python中以下数据会当做空来处理：

- 常量None。
- 常量False。
- 任何形式的数值类型零，如0、0L、0.0、0j。
- 空的序列，如''、()、[]。
- 空的字典，如{}。
- 当用户定义的类中定义了nonzero()方法和len()方法，并且该方法返回整数0或者布尔值False的时候。

其中常量None的特殊性体现在它既不是0、False，也不是空字符串，它就是一个空值对象。其数据类型为NoneType，遵循单例模式，是唯一的，因而不能创建None对象。所有赋值为None的变量都相等，并且None与任何其他非None的对象比较结果都为False。

## 连接字符串应优先使用join而不是+

join()方法和使用+操作符来连接字符串，join()方法的效率要高于+操作符，特别是字符串规模较大的时候，join()方法的优势更为明显（如连接数为100000的时候，两者耗时相差上百倍）。

## 格式化字符串时尽量使用.format方式而不是%

Python中内置的%操作符和.format方式都可用于格式化字符串。先来看看这两种具体格式化方法的基本语法形式和常见用法。

为什么要尽量使用format方式而不是%操作符来格式化字符串？

1. format方式在使用上较%操作符更为灵活。使用format方式时，参数的顺序与格式化的顺序不必完全相同。
2. format方式可以方便地作为参数传递。
3. ：%最终会被.format方式所代替。这个理由可以认为是最直接的原因，根据Python的官方文档（http://docs.python.org/2/library/std-types.html#string-formatting），.format()方法最终会取代%，在Python3.0中.format方法是推荐使用的方法，而之所以仍然保留%操作符是为了保持向后兼容。
4. %方法在某些特殊情况下使用时需要特别小心。

## 区别对待可变对象和不可变对象

这点比较新手，不讲解。

## []、()和{}：一致的容器初始化形式

列表是一个很有用的数据结构，它在Python中属于可变对象，列表中的元素没有限制，可以重复可以嵌套，操作上支持对单个元素的读取和修改，还支持分片、排序、插入、删除等。由于其灵活性，在实际应用中经常会看到它的身影。

List Comprehension是个好东西。

除了列表可以使用列表解析的语法之外，其他几种内置的数据结构也支持，比如元组（tuple）的初始化语法是（expr for iter_item in iterable ifcond_expr），而集合（set）的初始化语法是{exprfor iter_item in iterable if cond_expr}，甚至字典（dict）也有类似的语法{expr1, expr2 for iter_item in iterable if cond_expr}。




