#EMCAScript 6 入门

---

#EMCAScript6简介
1、部署进度

对ES6的支持可以查看<http://kangax.github.io/es5-compat-table/es6/>.Node.js和io.js对ES6的支持度比浏览器更高。

建议使用版本管理工具nvm

Node.js对ES6的支持，需要打开harmony参数

使用 node --v8-options | grep harmony 查看Node.js所有已经实现的ES6特性

2.Babel转码器

- 可以将ES6代码转为ES5代码
- 自带了一个babel-node命令 -- ES6的REPL环境。 也可以直接运行ES6脚本
- -o参数将转换后的代码，从标准输入导入文件
- -d参数用于转换整个目录
- -s参数用于生成source map文件
- 也可以用于浏览器

3. Traceur转码器

- 谷歌出品

- 允许直接将ES6代码直接嵌入网页。

- 提供了一个在线转换器<http://google.github.io/traceur-compiler/demo/repl.html#>

- 可以用npm转换

- --script指定输入文件 --out指定输出文件 最好 --experimental

4.ES7

1.Object.observe 用来监听对象（以及数组）的变化。一旦监听对象发生变化，就会触发回调函数。

2.Async函数：在Promise和Generator函数基础上，提出的异步操作解决方案

3.Multi-Threading：多线程支持。目前，Intel和Mozilla有一个共同的研究项目RiverTrail，致力于让JavaScript多线程运行。预计这个项目的研究成果会被纳入ECMAScript标准。

4.Traits：它将是“类”功能（class）的一个替代。通过它，不同的对象可以分享同样的特性。

其他可能包括的功能还有：更精确的数值计算、改善的内存回收、增强的跨站点安全、类型化的更贴近硬件的低级别操作、国际化支持（Internationalization Support）、更多的数据结构等等。

---
#let和const命令
- let用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效

- for循环的计数器，就很合适使用let命令。

- let不存在变量提升
- 使用在声明前就会出现error
- typeof不再是安全的操作
- 只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。
- 在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称TDZ）。
- 函数的作用域是其声明时所在的作用域。如果函数A的参数是函数B，那么函数B的作用域不是函数A。
- let不允许在相同作用域内，重复声明同一个变量。

###为什么需要块级作用域？
- 第一种场景：内层变量可能会覆盖外层变量。
- 第二种场景：用来计数的循环变量泄露为全局变量
- 块级作用域的出现，实际上使得获得广泛应用的立即执行匿名函数（IIFE）不再必要了。
- 函数本身的作用域，在其所在的块级作用域之内。
- 需要注意的是，如果在严格模式下，函数只能在顶层作用域和函数内声明，其他情况（比如if代码块、循环代码块）的声明都会报错。

###const命令
- const的作用域与let命令相同：只在声明所在的块级作用域内有效。
- 同样不支持变量提升
- 也与let一样不可重复声明。
- const命令只是指向变量所在的地址，所以将一个对象声明为常量必须非常小心。
- 如果真的想将对象冻结，应该使用Object.freeze方法。
- 对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。

###跨模块常量
export const constname = value;

import * as constants from './constants';

###全局对象的属性
ES6规定，var命令和function命令声明的全局变量，属于全局对象的属性；let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。

---
#变量的解构赋值

###1.数组的解构赋值

- ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。
- 本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。
- 解构不成功	，返回undefined
- 只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。
- 如果对undefined或null进行解构，会报错。
- 解构只能用于数组或对象。其他原始类型的值都可以转为相应的对象，但是，undefined和null不能转为对象，因此报错。
- 解构赋值允许指定默认值。ES6内部使用严格相等运算符（===），判断一个位置是否有值。
- 对于Set结构，也可以使用数组的解构赋值
- 只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值。

###2.对象的解构赋值
- 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。
- 如果对象名和属性名不一致，需要标示value；
- 也可以用来标示嵌套解构的对象
- 也可以使用默认值
- 如果要将一个已经声明的变量用于解构赋值，必须非常小心。

###3.字符串的解构赋值
- 字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。
- 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。

###4.函数参数的解构赋值
- 函数的参数也可以使用解构。
- 函数参数的解构也可以使用默认值。

###不能使用圆括号的情况
1. 变量声明语句中，模式不能带有圆括号。
2. 函数参数中，模式不能带有圆括号。
3. 不能将整个模式，或嵌套模式中的一层，放在圆括号之中。

###可以使用圆括号的情况
可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。

###用途
1. 交换变量的值
2. 从函数返回多个值
3. 函数参数的定义
4. 提取JSON数据
5. 函数参数的默认值
6. 遍历Map结构
7. 输入模块的指定方法

---
# 字符串的拓展
### 字符的Unicode表示法
1. 只要将码点放入大括号，就能正确解读该字符。
2. 大括号表示法与四字节的UTF-16编码是等价的。

### String.fromCodePoint()
1. ES5提供String.fromCharCode方法，用于从码点返回对应字符，但是这个方法不能识别辅助平面的字符
2. ES6提供了String.fromCodePoint方法，可以识别0xFFFF的字符，弥补String.fromCharCode方法的不足。在作用上，正好与codePointAt方法相反。
3. fromCodePoint方法定义在String对象上，而codePointAt方法定义在字符串的实例对象上。

### String.codePointAt()
1. ES6提供了codePointAt方法，能够正确处理4个字节储存的字符，返回一个字符的码点。
2. codePointAt方法会正确返回四字节的UTF-16字符的码点。对于那些两个字节储存的常规字符，它的返回结果与charCodeAt方法相同。
3. 是测试一个字符由两个字节还是由四个字节组成的最简单方法。

### at()
1. ES7提供了字符串实例的at方法，可以识别Unicode编号大于0xFFFF的字符，返回正确的字符。Chrome浏览器已经支持该方法。
2. ES5对字符串对象提供charAt方法，返回字符串给定位置的字符。该方法不能识别码点大于0xFFFF的字符。

### normalize()
1. 为了表示语调和重音符号，Unicode提供了两种方法。一种是直接提供带重音符号的字符，比如Ǒ（\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如O（\u004F）和ˇ（\u030C）合成Ǒ（\u004F\u030C）。
2. 这两种表示方法，在视觉和语义上都等价，但是JavaScript不能识别。
3. ES6提供String.prototype.normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为Unicode正规化。
4. normalize方法可以接受四个参数。
	1. NFC，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。
	2. NFD，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。
	3. NFKC，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。
	4. NFKD，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。
5. normalize方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过Unicode编号区间判断。

### includes(), startsWith(), endsWith()
1. JavaScript只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法。
	- includes()：返回布尔值，表示是否找到了参数字符串。
	- startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。
	- endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。
2. 这三个方法都支持第二个参数，表示开始搜索的位置。

### repeat()
repeat()返回一个新字符串，表示将原字符串重复n次。

### 模板字符串
1. 模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。
2. 如果在模板字符串中需要使用反引号，则前面要用反斜杠转义
3. 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。
4. 模板字符串中嵌入变量，需要将变量名写在${}之中。
5. 模板字符串之中还能调用函数。
6. 如果大括号中的值不是字符串，将按照一般的规则转为字符串。不如，大括号中是一个对象，将默认调用对象的toString方法。
7. 如果模板字符串中的变量没有声明，将报错。

### 标签模板
1. 它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。
2. “标签模板”的一个重要应用，就是过滤HTML字符串，防止用户输入恶意内容。
3. 标签模板的另一个应用，就是多语言转换（国际化处理）。
4. 模板字符串本身并不能取代Mustache之类的模板函数，因为没有条件判断和循环处理功能，但是通过标签函数，你可以自己添加这些功能。
5. 除此之外，你甚至可以使用标签模板，在JavaScript语言之中嵌入其他语言。
6. 模板处理函数的第一个参数（模板字符串数组），还有一个raw属性。

###String.raw()
1. String.raw方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。
2. String.raw方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。
3. String.raw方法也可以作为正常的函数使用。这时，它的第一个参数，应该是一个具有raw属性的对象，且raw属性的值应该是一个数组。

---


#数值的扩展
### 二进制和八进制表示法
1. ES6提供了二进制和八进制数值的新的写法，分别用前缀0b和0o表示。
2. 八进制不再允许使用前缀0表示，而改为使用前缀0o。

#
## Number.isFinite(), Number.isNaN()
1. Number.isFinite()用来检查一个数值是否非无穷（infinity）。
2. Number.isNaN()用来检查一个值是否为NaN。
3. 它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，非数值一律返回false。

### Number.parseInt(), Number.parseFloat()
1. ES6将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。
2. 这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。

### Number.isInteger()和安全整数

1. Number.isInteger()用来判断一个值是否为整数。需要注意的是，在JavaScript内部，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值。
2. JavaScript能够准确表示的整数范围在-2ˆ53 and 2ˆ53之间。ES6引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限。Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。

### Math对象的扩展

ES6在Math对象上新增了17个与数学相关的方法。所有这些方法都是静态方法，只能在Math对象上调用。

### Math.trunc()
1. Math.trunc方法用于去除一个数的小数部分，返回整数部分。
2. 对于空值和无法截取整数的值，返回NaN。

### Math.sign()
1. Math.sign方法用来判断一个数到底是正数、负数、还是零。
2. 它会返回五种值。
	- 参数为正数，返回+1；
	- 参数为负数，返回-1；
	- 参数为0，返回0；
	- 参数为-0，返回-0;
	- 其他值，返回NaN。

### Math.cbrt()
1. Math.cbrt方法用于计算一个数的立方根。

### Math.clz32()
1. JavaScript的整数使用32位二进制形式表示，Math.clz32方法返回一个数的32位无符号整数形式有多少个前导0。
2. 对于小数，Math.clz32方法只考虑整数部分。
3. 对于空值或其他类型的值，Math.clz32方法会将它们先转为数值，然后再计算。

### Math.imul()
1. Math.imul方法返回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号整数。
2. 如果只考虑最后32位（含第一个整数位），大多数情况下，Math.imul(a, b)与a * b的结果是相同的，即该方法等同于(a * b)|0的效果。之所以需要部署这个方法，是因为JavaScript有精度限制，超过2的53次方的值无法精确表示。这就是说，对于那些很大的数的乘法，低位数值往往都是不精确的，Math.imul方法可以返回正确的低位数值。

### Math.fround()
1. Math.fround方法返回一个数的单精度浮点数形式。
2. 对于整数来说，Math.fround方法返回结果不会有任何不同，区别主要是那些无法用64个二进制位精确表示的小数。这时，Math.fround方法会返回最接近这个小数的单精度浮点数。

### Math.hypot()
1. Math.hypot方法返回所有参数的平方和的平方根。
2. 如果参数不是数值，Math.hypot方法会将其转为数值。只要有一个参数无法转为数值，就会返回NaN。

### Math.expm1()
1. Math.expm1(x)返回ex - 1。

### Math.log1p()
1. Math.log1p(x)方法返回1 + x的自然对数。如果x小于-1，返回NaN。

### Math.log10()
1. Math.log10(x)返回以10为底的x的对数。如果x小于0，则返回NaN。
 
### Math.log2()
1. Math.log2(x)返回以2为底的x的对数。如果x小于0，则返回NaN。

### ES6新增了6个三角函数方法。
- Math.sinh(x) 返回x的双曲正弦（hyperbolic sine）
- Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine）
- Math.tanh(x) 返回x的双曲正切（hyperbolic tangent）
- Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine）
- Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine）
- Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent）

#数组的拓展
### Array.from（）
1. Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。
2. Array.from方法可以将函数的arguments对象，转为数组。
3. 任何有length属性的对象，都可以通过Array.from方法转为数组。
4. 对于还没有部署该方法的浏览器，可以用Array.prototype.slice方法替代。
5. Array.from()还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理。
6. Array.from()的另一个应用是，将字符串转为数组，然后返回字符串的长度。这样可以避免JavaScript将大于\uFFFF的Unicode字符，算作两个字符的bug。

### Array.of()
1. Array.of方法用于将一组值，转换为数组。
2. 这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。

### 数组实例的find()和findIndex()
1. 数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。
2. find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。
3. 数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。
4. 这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。
5. 另外，这两个方法都可以发现NaN，弥补了数组的IndexOf方法的不足。

### 数组实例的fill()
1. fill()使用给定值，填充一个数组。
2. fill方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。
3. fill()还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。

### 数组实例的entries()，keys()和values()
1. ES6提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用for...of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。
2. 如果不使用for...of循环，可以手动调用遍历器对象的next方法，进行遍历。

### 数组实例的includes()
1. Array.protypeto.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。该方法属于ES7，但Babel转码器已经支持。
2. 该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。
3. 没有该方法之前，我们通常使用数组的indexOf方法，检查是否包含某个值。
4. indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相当运算符（===）进行判断，这会导致对NaN的误判。
5. includes使用的是不一样的判断算法，就没有这个问题。
6. 另外，Map和Set数据结构有一个has方法，需要注意与includes区分。

### 数组推导
1. 数组推导（array comprehension）提供简洁写法，允许直接通过现有数组生成新数组。这项功能本来是要放入ES6的，但是TC39委员会想继续完善这项功能，让其支持所有数据结构（内部调用iterator对象），不像现在只支持数组，所以就把它推迟到了ES7。Babel转码器已经支持这个功能。
2. if语句写在for...of与返回的表达式之间，可以使用多个if语句。
3. 数组推导可以替代map和filter方法。
4. 在一个数组推导中，还可以使用多个for...of结构，构成多重循环。
5. 需要注意的是，数组推导的方括号构成了一个单独的作用域，在这个方括号中声明的变量类似于使用let语句声明的变量。
6. 数组推导需要注意的地方是，新数组会立即在内存中生成。这时，如果原数组是一个很大的数组，将会非常耗费内存。

### Array.observe()，Array.unobserve()
1. 这两个方法用于监听（取消监听）数组的变化，指定回调函数。扩展运算符2. 
2. 它们的用法与Object.observe和Object.unobserve方法完全一致，也属于ES7的一部分，请参阅《对象的扩展》一章。唯一的区别是，对象可监听的变化一共有六种，而数组只有四种：add、update、delete、splice（数组的length属性发生变化）。

---
# 函数的扩展
### 函数参数的默认值
1. 在ES6之前，不能直接为函数的参数指定默认值，只能采用变通的方法。
2. ES6允许为函数的参数设置默认值，即直接写在参数定义的后面。
3. 首先，阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档；
4. 其次，有利于将来的代码优化，即使未来的版本彻底拿到这个参数，也不会导致以前的代码无法运行。
5. 甚至还可以设置双重默认值。
6. 定义了默认值的参数，必须是函数的尾部参数，其后不能再有其他无默认值的参数。
7. 如果传入undefined，将触发该参数等于默认值，null则没有这个效果。
8. 指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。
9. 另一个需要注意的地方是，参数默认值所处的作用域，不是全局作用域，而是函数作用域。
10. 参数变量是默认声明的，所以不能用let或const再次声明。
11. 参数默认值可以与解构赋值，联合起来使用。

### rest参数
1. ES6引入rest参数（形式为“...变量名”），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。
2. rest参数中的变量代表一个数组，所以数组特有的方法都可以用于这个变量。
3. rest参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。
4. 函数的length属性，不包括rest参数。

### 扩展运算符
1. 扩展运算符（spread）是三个点（...）。它好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。
2. 该运算符主要用于函数调用。
3. 由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。
4. 扩展运算符与正常的函数参数可以结合使用，非常灵活。
5. 扩展运算符可以简化很多种ES5的写法。
6. 扩展运算符也可以与解构赋值结合起来，用于生成数组。
7. 如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。
8. JavaScript的函数只能返回一个值，如果需要返回多个值，只能返回数组或对象。扩展运算符提供了解决这个问题的一种变通方法。
9. 扩展运算符还可以将字符串转为真正的数组。
10. 任何类似数组的对象，都可以用扩展运算符转为真正的数组。
11. 扩展运算符内部调用的是数据结构的Iterator接口，因此只要具有Iterator接口的对象，都可以使用扩展运算符，比如Map结构。

### 箭头函数
1. ES6允许使用“箭头”（=>）定义函数。
2. 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。
3. 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。
4. 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。
5. 箭头函数可以与变量解构结合使用。
6. 箭头函数的一个用处是简化回调函数。
7. 函数体内的this对象，绑定定义时所在的对象，而不是使用时所在的对象。
8. 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。
9. 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。
10. 不可以使用yield命令，因此箭头函数不能用作Generator函数。
11. 第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。下面的代码是一个例子，将this对象绑定定义时所在的对象。

### 嵌套的箭头函数
1. 箭头函数内部，还可以再使用箭头函数。
2. 箭头函数还有一个功能，就是可以很方便地改写λ演算。

### 函数绑定
1. ES7提出了“函数绑定”（function bind）运算符，用来取代call、apply、bind调用。
2. 函数绑定运算符是并排的两个双引号（::），双引号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。

### 尾递归优化
1. 函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。
2. 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。
3. “尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。
4. 如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。
5. 注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。
6. 递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。
7. “尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6也是如此，第一次明确规定，所有ECMAScript的实现，都必须部署“尾调用优化”。这就是说，在ES6中，只要使用尾递归，就不会发生栈溢出，相对节省内存。
8. 目前，只有开启严格模式，尾调用优化才会生效。
9. 尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。
10. 函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。
11. 第二种方法就简单多了，就是采用ES6的函数默认值。
12. 总结一下，递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持“尾调用优化”的语言（比如Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。

---
# 对象的拓展
### 属性的简洁表示法
1. ES6允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。
2. 这种写法用于函数的返回值，将会非常方便。
3. 赋值器和取值器，也可以采用简洁写法。

### 属性名表达式
1. ES6允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。
2. 表达式还可以用于定义方法名。

### 方法的name属性
1. 函数的name属性，返回函数名。ES6为对象方法也添加了name属性。
2. 如果使用了取值函数，则会在方法名前加上get。如果是存值函数，方法名的前面会加上set。
3. bind方法创造的函数，name属性返回“bound”加上原函数的名字；Function构造函数创造的函数，name属性返回“anonymous”。

### Object.is()
1. Object.is()用来比较两个值是否严格相等。它与严格比较运算符（===）的行为基本一致，不同之处只有两个：一是+0不等于-0，二是NaN等于自身。

### Object.assign()
1. Object.assign方法用来将源对象（source）的所有可枚举属性，复制到目标对象（target）。它至少需要两个对象作为参数，第一个参数是目标对象，后面的参数都是源对象。只要有一个参数不是对象，就会抛出TypeError错误。
2. 如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。
3. 为对象添加属性
4. 为对象添加方法
5. 克隆对象
6. 合并多个对象
7. 为属性指定默认值

### proto属性，Object.setPrototypeOf()，Object.getPrototypeOf()
1. proto属性，用来读取或设置当前对象的prototype对象。该属性一度被正式写入ES6草案，但后来又被移除。目前，所有浏览器（包括IE11）都部署了这个属性。
2. 有了这个属性，实际上已经不需要通过Object.create()来生成新对象了。
3. Object.setPrototypeOf方法的作用与proto相同，用来设置一个对象的prototype对象。它是ES6正式推荐的设置原型对象的方法。
4. Object.getPrototypeOf() 该方法与setPrototypeOf方法配套，用于读取一个对象的prototype对象。

### Object.observe()，Object.unobserve()
1. Object.observe方法用来监听对象（以及数组）的变化。一旦监听对象发生变化，就会触发回调函数。
2. 一般情况下，Object.observe方法接受两个参数，第一个参数是监听的对象，第二个函数是一个回调函数。一旦监听对象发生变化（比如新增或删除一个属性），就会触发这个回调函数。很明显，利用这个方法可以做很多事情，比如自动更新DOM。
3. 回调函数的changes参数是一个数组，代表对象发生的变化。
4. Object.observe方法目前共支持监听六种变化。
	- add：添加属性
	- update：属性值的变化
	- delete：删除属性
	- setPrototype：设置原型
	- reconfigure：属性的attributes对象发生变化
	- preventExtensions：对象被禁止扩展（当一个对象变得不可扩展时，也就不必再监听了）

5. Object.observe方法还可以接受第三个参数，用来指定监听的事件种类
6. Object.unobserve方法用来取消监听。
7. Object.observe和Object.unobserve这两个方法不属于ES6，而是属于ES7的一部分。不过，Chrome浏览器从33版起就已经支持。

### 对象的扩展运算符
1. 目前，ES7有一个提案，将rest参数/扩展运算符（...）引入对象。Babel转码器已经支持这项功能。
2. Rest参数用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。
3. 注意，Rest参数的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么Rest参数拷贝的是这个值的引用，而不是这个值的副本。
4. 另外，Rest参数不会拷贝继承自原型对象的属性。
5. 扩展运算符用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。
6. 这等同于使用Object.assign方法。
7. 扩展运算符可以用于合并两个对象。
8. 扩展运算符还可以用自定义属性，会在新对象之中，覆盖掉原有参数。
9. 如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。
10. 扩展运算符的参数对象之中，如果有取值函数get，这个函数是会执行的。

# Symbol
### 概述
1. ES5的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法，新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是ES6引入Symbol的原因。
2. ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。
3. Symbol值通过Symbol函数生成。
4. 这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的Symbol类型。凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。
5. Symbol函数前不能使用new命令，否则会报错。这是因为生成的Symbol是一个原始类型的值，不是对象。
6. Symbol函数可以接受一个字符串作为参数，表示对Symbol实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分
7. 注意，Symbol函数的参数只是表示对当前Symbol值的描述，因此相同参数的Symbol函数的返回值是不相等的。
8.  Symbol值不能与其他类型的值进行运算，会报错。但是，Symbol值可以转为字符串。

### 作为属性名的Symbol
1. 由于每一个Symbol值都是不相等的，这意味着Symbol值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。
2. 注意，Symbol值作为对象属性名时，不能用点运算符。
3. 同理，在对象的内部，使用Symbol值定义属性时，Symbol值必须放在方括号之中。
4. 采用增强的对象写法，上面代码的obj对象可以写得更简洁一些。
5. Symbol类型还可以用于定义一组常量，保证这组常量的值都是不相等的。
6. 还有一点需要注意，Symbol值作为属性名时，该属性还是公开属性，不是私有属性。

### 属性名的遍历
1. Symbol作为属性名，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有Symbol属性名。
2. Object.getOwnPropertySymbols方法返回一个数组，成员是当前对象的所有用作属性名的Symbol值。
3. 另一个新的API，Reflect.ownKeys方法可以返回所有类型的键名，包括常规键名和Symbol键名。
4. 由于以Symbol值作为名称的属性，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。

### Symbol.for()，Symbol.keyFor()
1. 有时，我们希望重新使用同一个Symbol值，Symbol.for方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。
2. Symbol.for()与Symbol()这两种写法，都会生成新的Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。Symbol.for()不会每次调用就返回一个新的Symbol类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。比如，如果你调用Symbol.for("cat")30次，每次都会返回同一个Symbol值，但是调用Symbol("cat")30次，会返回30个不同的Symbol值。
3. 需要注意的是，Symbol.for为Symbol值登记的名字，是全局环境的，可以在不同的iframe或service worker中取到同一个值。

### 内置的Symbol值
1. 除了定义自己使用的Symbol值以外，ES6还提供一些内置的Symbol值，指向语言内部使用的方法。
2. Symbol.hasInstance 对象的Symbol.hasInstance属性，指向一个内部方法。该对象使用instanceof运算符时，会调用这个方法，判断该对象是否为某个构造函数的实例。比如，foo instanceof Foo在语言内部，实际调用的是Foo[Symbol.hasInstance](foo)。
3. Symbol.isConcatSpreadable 对象的Symbol.isConcatSpreadable属性，指向一个方法。该对象使用Array.prototype.concat()时，会调用这个方法，返回一个布尔值，表示该对象是否可以扩展成数组。
4. Symbol.isRegExp 对象的Symbol.isRegExp属性，指向一个方法。该对象被用作正则表达式时，会调用这个方法，返回一个布尔值，表示该对象是否为一个正则对象。
5. Symbol.match 对象的Symbol.match属性，指向一个函数。当执行str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值。
6. Symbol.replace 对象的Symbol.replace属性，指向一个方法，当该对象被String.prototype.replace方法调用时，会返回该方法的返回值。
7. Symbol.search 对象的Symbol.search属性，指向一个方法，当该对象被String.prototype.search方法调用时，会返回该方法的返回值。
8. Symbol.split 对象的Symbol.split属性，指向一个方法，当该对象被String.prototype.split方法调用时，会返回该方法的返回值。
9. Symbol.iterator 对象的Symbol.iterator属性，指向该对象的默认遍历器方法，即该对象进行for...of循环时，会调用这个方法，返回该对象的默认遍历器，详细介绍参见《Iterator和for...of循环》一章。
10. Symbol.toPrimitive 对象的Symbol.toPrimitive属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。
11. Symbol.toStringTag 对象的Symbol.toStringTag属性，指向一个方法。在该对象上面调用Object.prototype.toString方法时，如果这个属性存在，它的返回值会出现在toString方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制[object Object]或[object Array]中object后面的那个字符串。
12. Symbol.unscopables 对象的Symbol.unscopables属性，指向一个对象。该对象指定了使用with关键字时，哪些属性会被with环境排除。

# Proxy和Reflect
### Proxy概述
1. Proxy用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。
2. Proxy可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。
3. 上面代码说明，Proxy实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。
4. ES6原生提供Proxy构造函数，用来生成Proxy实例。
5. Proxy对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。
6. 其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。
7. 要使得Proxy起作用，必须针对Proxy实例（上例是proxy对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。
8. 一个技巧是将Proxy对象，设置到object.proxy属性，从而可以在object对象上调用。
9. Proxy实例也可以作为其他对象的原型对象。
10. proxy对象是obj对象的原型，obj对象本身并没有time属性，所以根据原型链，会在proxy对象上读取该属性，导致被拦截。
11. 同一个拦截器函数，可以设置拦截多个操作。

### Proxy实例的方法
1. get()
2. 利用proxy，可以将读取属性的操作（get），转变为执行某个函数。
3. set()
4. set方法用来拦截某个属性的赋值操作。
5. apply()
6. apply方法拦截函数的调用、call和apply操作。
7. ownKeys()
8. ownKeys方法用来拦截Object.keys()操作。
9. Proxy.revocable()
10. Proxy.revocable方法返回一个可取消的Proxy实例。

### Reflect概述
1. Reflect对象与Proxy对象一样，也是ES6为了操作对象而提供的新API。Reflect对象的设计目的有这样几个。
2.  将Object对象的一些明显属于语言层面的方法，放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。
3.   修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。
4.   让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。
5.  Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。
6. 上面这些方法的作用，大部分与Object对象的同名方法的作用都是相同的。下面是对其中几个方法的解释。

### Reflect对象的方法
1. Reflect.get(target,name,receiver)
2. 查找并返回target对象的name属性，如果没有该属性，则返回undefined。
3. Reflect.set(target, name, value, receiver)
4. 设置target对象的name属性等于value。如果name属性设置了赋值函数，则赋值函数的this绑定receiver。
5. Reflect.has(obj, name)
6. 等同于name in obj。 
7. Reflect.deleteProperty(obj, name)
8. 等同于delete obj[name]。
9. Reflect.construct(target, args)
10. 等同于new target(...args)，这提供了一种不使用new，来调用构造函数的方法。
11. Reflect.getPrototypeOf(obj）
12. 读取对象的__proto__属性，等同于Object.getPrototypeOf(obj)。
13. Reflect.setPrototypeOf(obj, newProto)
14. 设置对象的__proto__属性。注意，Object对象没有对应这个方法的方法。
15. Reflect.apply(fun,thisArg,args)
16. 等同于Function.prototype.apply.call(fun,thisArg,args)。一般来说，如果要绑定一个函数的this对象，可以这样写fn.apply(obj, args)，但是如果函数定义了自己的apply方法，就只能写成Function.prototype.apply.call(fn, obj, args)，采用Reflect对象可以简化这种操作。
17. Reflect.set()、Reflect.defineProperty()、Reflect.freeze()、Reflect.seal()和Reflect.preventExtensions()返回一个布尔值，表示操作是否成功。它们对应的Object方法，失败时都会抛出错误。

# Set和Map数据结构
### Set
1. ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。
2. Set本身是一个构造函数，用来生成Set数据结构。
3. Set函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。
4. 向Set加入值的时候，不会发生类型转换，所以5和"5"是两个不同的值。Set内部判断两个值是否不同，使用的算法类似于精确相等运算符（===），这意味着，两个对象总是不相等的。唯一的例外是NaN等于自身（精确相等运算符认为NaN不等于自身）。
5. Set结构的实例有以下属性。
6. Set.prototype.constructor：构造函数，默认就是Set函数。
7. Set.prototype.size：返回Set实例的成员总数。
8. Set实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。
9. add(value)：添加某个值，返回Set结构本身。
10. delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。
11. has(value)：返回一个布尔值，表示该值是否为Set的成员。
12. clear()：清除所有成员，没有返回值。
13. Array.from方法可以将Set结构转为数组。
14. 遍历操作Set结构的实例有四个遍历方法，可以用于遍历成员。
15. keys()：返回一个键名的遍历器
16. values()：返回一个键值的遍历器
17. entries()：返回一个键值对的遍历器
18. forEach()：使用回调函数遍历每个成员
19. Set结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法。
20. 这意味着，可以省略values方法，直接用for...of循环遍历Set。
21. 由于扩展运算符（...）内部使用for...of循环，所以也可以用于Set结构。
22. 而且，数组的map和filter方法也可以用于Set了。
23. 因此使用Set，可以很容易地实现并集（Union）和交集（Intersect）。
24. Set结构的实例的forEach方法，用于对每个成员执行某种操作，没有返回值。
25. 如果想在遍历操作中，同步改变原来的Set结构，目前没有直接的方法，但有两种变通方法。一种是利用原Set结构映射出一个新的结构，然后赋值给原来的Set结构；另一种是利用Array.from方法。

### WeakSet
1. WeakSet结构与Set类似，也是不重复的值的集合。但是，它与Set有两个区别。
2. 首先，WeakSet的成员只能是对象，而不能是其他类型的值。
3. 其次，WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于WeakSet之中。这个特点意味着，无法引用WeakSet的成员，因此WeakSet是不可遍历的。
4. WeakSet是一个构造函数，可以使用new命令，创建WeakSet数据结构。
5. 作为构造函数，WeakSet可以接受一个数组或类似数组的对象作为参数。（实际上，任何具有iterable接口的对象，都可以作为WeakSet的参数。）该数组的所有成员，都会自动成为WeakSet实例对象的成员。
6. WeakSet结构有以下三个方法。
7. WeakSet.prototype.add(value)：向WeakSet实例添加一个新成员。
8. WeakSet.prototype.delete(value)：清除WeakSet实例的指定成员。
9. WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在WeakSet实例之中。
10. WeakSet没有size属性，没有办法遍历它的成员。
11. WeakSet不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保存成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。

### Map
1. Map结构的目的和基本用法
2. JavaScript的对象（Object），本质上是键值对的集合（Hash结构），但是只能用字符串当作键。这给它的使用带来了很大的限制。
3. 上面代码原意是将一个DOM节点作为对象data的键，但是由于对象只接受字符串作为键名，所以element被自动转为字符串[Object HTMLDivElement]。
4. 上面代码原意是将一个DOM节点作为对象data的键，但是由于对象只接受字符串作为键名，所以element被自动转为字符串[Object HTMLDivElement]。
5. 为了解决这个问题，ES6提供了Map数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。
6. 上面代码使用set方法，将对象o当作m的一个键，然后又使用get方法读取这个键，接着使用delete方法删除了这个键。
7. 作为构造函数，Map也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。
8. Map构造函数接受数组作为参数，实际上执行的是下面的算法。
9. 如果对同一个键多次赋值，后面的值将覆盖前面的值。
10. 如果读取一个未知的键，则返回undefined。
11. 只有对同一个对象的引用，Map结构才将其视为同一个键。这一点要非常小心
12. 上面代码的set和get方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此get方法无法读取该键，返回undefined。
13. 同理，同样的值的两个实例，在Map结构中被视为两个键。
14. 由上可知，Map的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。
15. 如果Map的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map将其视为一个键，包括0和-0。另外，虽然NaN不严格相等于自身，但Map将其视为同一个键。
16. size属性 返回Map结构的成员总数。
17. set(key, value) set方法设置key所对应的键值，然后返回整个Map结构。如果key已经有值，则键值会被更新，否则就新生成该键。
18. set方法返回的是Map本身，因此可以采用链式写法。
19. get(key) get方法读取key对应的键值，如果找不到key，返回undefined。
20. has(key) has方法返回一个布尔值，表示某个键是否在Map数据结构中
21. delete(key) delete方法删除某个键，返回true。如果删除失败，返回false。
22. clear() clear方法清除所有成员，没有返回值。
23. Map原生提供三个遍历器生成函数和一个遍历方法。
24. Map结构转为数组结构，比较快速的方法是结合使用扩展运算符（...）。
25. 结合数组的map方法、filter方法，可以实现Map的遍历和过滤（Map本身没有map和filter方法）。
26. 此外，Map还有一个forEach方法，与数组的forEach方法类似，也可以实现遍历。
27. forEach方法还可以接受第二个参数，用来绑定this。
28. 数组转为Map
29. 将数组转入Map构造函数，就可以转为Map。
30. Map转为对象
31. 如果所有Map的键都是字符串，它可以转为对象。
32. 对象转为Map
33. Map转为JSON
34. Map转为JSON要区分两种情况。一种情况是，Map的键名都是字符串，这时可以选择转为对象JSON。
35. 另一种情况是，Map的键名有非字符串，这时可以选择转为数组JSON。
36. JSON转为Map
37. 但是，有一种特殊情况，整个JSON就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为Map。这往往是数组转为JSON的逆操作。

### WeakMap
1. WeakMap的设计目的在于，键名是对象的弱引用（垃圾回收机制不将该引用考虑在内），所以其所对应的对象可能会被自动回收。当对象被回收后，WeakMap自动移除对应的键值对。典型应用是，一个对应DOM元素的WeakMap结构，当某个DOM元素被清除，其所对应的WeakMap记录就会自动被移除。基本上，WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏。
2. WeakMap与Map在API上的区别主要是两个，一是没有遍历操作（即没有key()、values()和entries()方法），也没有size属性；二是无法清空，即不支持clear方法。这与WeakMap的键不被计入引用、被垃圾回收机制忽略有关。因此，WeakMap只有四个方法可用：get()、set()、has()、delete()。
3. 上面代码中，myElement是一个DOM节点，每当发生click事件，就更新一下状态。我们将这个状态作为键值放在WeakMap里，对应的键名就是myElement。一旦这个DOM节点删除，该状态就会自动消失，不存在内存泄漏风险。
4. WeakMap的另一个用处是部署私有属性。

# Iterator和for...of循环
### Iterator（遍历器）的概念
1. JavaScript原有的表示“集合”的数据结构，主要是数组（Array）和对象（Object），ES6又添加了Map和Set。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是Map，Map的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。
2. 遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。
3. Iterator的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是ES6创造了一种新的遍历命令for...of循环，Iterator接口主要供for...of消费。
4. 每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。
5. 遍历器对象本质上，就是一个指针对象。
6. 总之，调用指针对象的next方法，就可以遍历事先给定的数据结构。
7. 由于Iterator只是把接口规格加到数据结构之上，所以，遍历器与它所遍历的那个数据结构，实际上是分开的，完全可以写出没有对应数据结构的遍历器对象，或者说用遍历器对象模拟出数据结构。下面是一个无限运行的遍历器对象的例子。
8. 在ES6中，有些数据结构原生具备Iterator接口（比如数组），即不用任何处理，就可以被for...of循环遍历，有些就不行（比如对象）。原因在于，这些数据结构原生部署了Symbol.iterator属性（详见下文），另外一些数据结构没有。凡是部署了Symbol.iterator属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。

### 数据结构的默认Iterator接口
1. ES6规定，默认的Iterator接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）。调用Symbol.iterator方法，就会得到当前数据结构默认的遍历器生成函数。Symbol.iterator本身是一个表达式，返回Symbol对象的iterator属性，这是一个预定义好的、类型为Symbol的特殊值，所以要放在方括号内（请参考Symbol一章）
2. 













