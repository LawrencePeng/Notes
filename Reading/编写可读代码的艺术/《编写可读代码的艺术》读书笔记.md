title: 《编写可读代码的艺术》读书笔记
tag: [编程, 代码, 可读]
category: 读书
------


今天看了《编写可读代码的艺术》，献上笔记。

书如其名，该书堪称是一个一条龙服务地教授如何写出可读代码的服务。博主[4G Space](http://blog.youxu.info)就说过他在Google工作时看到的代码几乎都是这本书提及的这种可读性高的代码。本书很推荐阅读。

本书分成四部分：

**表面层次上的改进** -- 命名、注释以及审美

**简化循环和逻辑** -- 在程序中定义循环、逻辑和变量，从而使得代码更容易理解。

**重新组织你的代码** -- 在更高层次上组织大的代码块以及在功能层次上解决问题的方法。

**精选话题** -- 把"易于理解"的思想应用于测试以及大数据结构代码的例子。

# 代码应该易于理解

> 可读性基本定理 -- 代码的写法应当使别人理解它所需的时间最小化。


# 表面层次上的改进


## 把信息装进名字里

> There are only two hard things in Computer Science: cache invalidation and naming things.*

本章关注:把信息装入名字中。

### 选择专业的词

很多词汇，比如get、size都没能表达出很多信息。选取合适的动词、名词。明确要表示的信息，而不是泛泛而谈。

#### 找到更有表现力的词

下面的例子中，这些单词更有表现力。

Send -> Deliver、Dispatch、Announce、Distribute、Route

Find -> Search、Extract、Locate、Recover

Start -> Launch、Create、Begin、Open

Make -> Create、Set up、Build、Generate、Compose、Add、New

> 清晰和精确比装可爱好。

### 避免像tmp和retval这样泛泛的名字

**retval这个名字没有包含很多信息。用一个描述该变量的值的名字来代替它。**

**tmp这个名字只应用于短期存在且临时性为其主要存在因素的变量。**

**如果有更精确的词，应该避免诸如i，j这样的名字命名循环迭代器。**

**如果你要使用像tmp、it或者retval这样空泛的名字，那么你要有个好的理由。**

### 用具体的名字代替抽象的名字

**在给变量、函数或者其他元素命名时，要把它描述得更具体而不是更抽象。**

例如，假设你有一个内部方法叫做ServerCanStart()，它检测服务是否可以监听某个给定的TCP/IP端口。然而ServerCanStart()有点抽象。CanListenOnPort()就更具体一些。这个名字直接地描述了这个方法要做什么事情。

精确的描述在干什么，而不是选取含义范围更大的词。

### 名字附带更多信息

一个变量名就像是一个小小的注释。尽管空间不是很大，但不管你在名中挤进任何额外的信息，每次有人看到这个变量名时都会同时看到这些信息。

如果关于一个变量有什么重要事情的读者必须知道，那么是值得把额外的“词”添加到名字中的。例如，假设你有一个变量包含一个十六进制字符串：

`string id; // Example: "af84ef845cd8" `这个注释看起来很不错，但是为什么不把id改成hex_id这个更加直观的名字呢？

#### 带单位的词

如果你的变量是一个度量的话（如时间长度或者字节数），那么最好把名字带上它的单位。

例如: 有个名字叫做start_time的变量，那么最好应该带上单位start_time_ms。

#### 附带其他重要属性

这种给名字附带额外信息的技巧不仅限于单位。在对于这个变量存在危险或者意外的任何时候你都该采用它。

但你不应该给程序中每个变量都加上像unescaped_或者_utf8这样的属性。如果有人误解了这个变量就很容易产生缺陷，尤其是会产生像安全缺陷这样可怕的结果，在这些地方这种技巧最有用武之地。基本上，如果这是一个需要理解的关键信息，那就把它放在名字里。

### 名字应该有多长

当选择好名字时，有一个隐含的约束是名字不能太长。

另一方面，程序员也可能走另一个极端，只用单个单词（或者单一字母）的名字。

最好的答案和这个变量如何使用有关系，但下面还是提出了一些指导原则。

#### 在小的作用域里可以使用短的名字

“作用域”小的标识符（对于多少行其他代码可见）也不用带上太多信息。

如果一个标识符有较大的作用域，那么它的名字就要包含足够的信息以便含义更清楚。

#### 输入长名字——不再是个问题

我们所见到的所有的编程文本编辑器都有内置的“单词补全”的功能。

所以，因为名字长输入慢而不选择使用长名字已经是说不过去的了。

#### 首字母缩略词和缩写

使用项目所特有的缩写词非常糟糕。

经验原则是：团队的新成员是否能理解这个名字的含义？如果能，那可能就没有问题。

#### 丢掉没用的词

有时名字中的某些单词可以拿掉而不会损失任何信息。例如ConvertToString就不如ToString好。

### 利用名字的格式来传递含义

遵循一定的命名规范很有好处。例如：使用CamelCase来表示类名，使用lower_separated来表示变量名。

例如，常量的格式是kConstantName而不是CONSTANT_NAME。这种形式的好处是容易和#define的宏区分开，宏的规范是MACRO_NAME。

类成员变量和普通变量一样，但必须以一条下划线结尾，如offset_。刚开始看，可能会觉得这个规范有点怪，但是能立刻区分出是成员变量还是其他变量，这一点还是很方便的。

#### 其他格式规范

根据项目上下文或语言的不同，还可以采用其他一些格式规范使得名字包含更多信息。

例如，在《JavaScript:The Good Parts》一书中，作者建议“构造函数”（在新建时会调用的函数）应该首字母大写而普通函数首字母小字。

是否要采用这些规范是由你和你的团队决定的。但不论你用哪个系统，在你的项目中要保持一致。

总结:

- 使用专业的单词——例如，不用Get，而用Fetch或者Download可能会更好，这由上下文决定。
- 避免空泛的名字，像tmp和retval，除非使用它们有特殊的理由。
- 使用具体的名字来更细致地描述事物——Server Can Start()这个名字就比CanListenOnPort更不清楚。
- 给变量名带上重要的细节——例如，在值为毫秒的变量后面加上_ms，或者在还需要转义的，未处理的变量前面加上raw_。
- 为作用域大的名字采用更长的名字——不要用让人费解的一一个或两个字母的名字来命名在几屏之间都可见的变量。对于只存在于几行之间的变量用短一点的名字更好。
- 有目的地使用大小写、下划线等——例如，你可以在类成员和局部变量后面加上"_"来区分它们。

## 不会误解的名字

本章关注: 小心可能会有歧义的名字。

> 要多问自己几遍：“这个名字会被别人解读成其他的含义吗？”

糟糕的例子:Filter()、Clip()。

推荐用min和max来表示（包含）极限。

**命名极限最清楚的方式是在要限制的东西前加上max_或者min_。**

**推荐用first和last来表示包含的范围**

**推荐用begin和end来表示包含/排除范围**

这两个建议是为了+-1问题而设计的。

**给布尔值命名**

通常来讲，加上像is、has、can或should这样的词，可以把布尔值变得更明确。

### 与使用者的期望相匹配

有些名字之所以会让人误解是因为用户对它们的含义有先入为主的印象，就算你的本意并非如此。在这种情况下，最好放弃这个名字而改用一个不会让人误解的名字。

例子: getXXX()可能会让人觉得是简单返回成员变量的函数。如果不是，最好不要用get。

总结

- 不会误解的名字是最好的名字——阅读你代码的人应该理解你的本意，并且不会有其他的理解。遗憾的是，很多英语单词在用来编程时是多义性的，例如filter、length和limit。
- 在你决定使用一个名字以前，要吹毛求疵一点，来想象一下你的名字会被误解成什么。最好的名字是不会误解的。
- 当要定义一个值的上限或下限时，max_和min_是很好的前缀。对于包含的范围，first和last是好的选择。对于包含/排除范围，begin和end是最好的选择，因为它们最常用。
- 当为布尔值命名时，使用is和has这样的词来明确表示它是个布尔值，避免使用反义的词（例如disable_ssl）。
- 要小心用户对特定词的期望。例如，用户会期望get()或者size()是轻量的方法。

## 审美


本章关注: 排版

确切地说，有三条原则：
·使用一致的布局，让读者很快就习惯这种风格。
·让相似的代码看上去相似。
·把相关的代码行分组，形成代码块。

好的审美与好的设计是两种独立的思想。最好是同时在两个方向上努力做到更好。

### 为什么审美这么重要

假设你不得不用这个类：

```
class StatsKeeper {
public:
// A class for keeping track of a series of doubles  
	void Add(double d); // and methods for quick statistics about them
	private: int count; /* how many so far
	*/ public:
	  double Average();
	  private: double minimum;
	  list<double>  
	  	past_items   
	  	;double maximum;
}; 
```
还是杀了我吧。

再看看这个版本。

```
// A class for keeping track of a series of doubles
// and methods for quick statistics about them.
class StatsKeeper {
  public:    
  	void Add(double d);
  	double Average();  
  private:    
  	list<double> past_items;    
  	int count; // how many so far    
  	double minimum;    
  	double maximum;
}; 
```

很明显，第二个版本有助于你的更快的阅读代码。

浏览代码的速度越快，人们就越容易使用它。

### 重新安排换行来保持一致和紧凑

相似的代码应当看上去相似。

为了让代码看上去更一致，我们可以引入更多的换行。例如

```
public class PerformanceTester {
  // TcpConnectionSimulator(throughput, latency, jitter, packet_loss)
  // [Kbps] [ms] [ms] [percent]
  public static final TcpConnectionSimulator wifi =
    new TcpConnectionSimulator(500, 80, 200, 1);
  public static final TcpConnectionSimulator t3_fiber =
    new TcpConnectionSimulator(45000, 10, 0, 0);
  public static final TcpConnectionSimulator cell =
    new TcpConnectionSimulator(100, 400, 250, 5);
} 
```
如此版本怎能不让人阅读时心情愉悦。


### 用方法来整理不规则的东西

就将功能相似但是规则不同的代码整理进一个函数值，即使这个函数可能有些混乱，但是因为重用的原因，你的代码也变得有条理起来。

假设你有一个个人数据库，它提供了下面这个函数：

```
// Turn a partial_name like "Doug Adams" into "Mr. Douglas Adams".
// If not possible, 'error' is filled with an explanation.
string ExpandFullName(DatabaseConnection dc, string partial_name, string* error); 
```

并且这个函数由一系列的例子来测试：

```
DatabaseConnection database_connection;
string error;
assert(ExpandFullName(database_connection, "Doug Adams", &error)
  == "Mr. Douglas Adams");
assert(error == "");
assert(ExpandFullName(database_connection, " Jake Brown ", &error)
  == "Mr. Jacob Brown III");
assert(error == "");
assert(ExpandFullName(database_connection, "No Such Guy", &error) == "");
assert(error == "no match found");
assert(ExpandFullName(database_connection, "John", &error) == "");
assert(error == "more than one result"); 
```

看上去没什么美感可言。有些行长得都换行了。这段代码的剪影很难看，也没有什么一致的风格。

但对于这种情况，重新布置换行也仅能做到如此。更大的问题是这里有很多重复的串，例如"assert（ExpandFullName（database_connection……"，其中还有很多的"error"。要是真的想改进这段代码，需要一个辅助方法。就像这样

```
CheckFullName("Doug Adams", "Mr. Douglas Adams", "");
CheckFullName(" Jake Brown ", "Mr. Jake Brown III", "");
CheckFullName("No Such Guy", "", "no match found");
CheckFullName("John", "", "more than one result"); 
```

使代码“看上去漂亮”通常会带来不限于表面层次的改进，它可能会帮你把代码的结构做得更好。

### 在需要时使用列对齐

整齐的边和列让读者可轻松地浏览文本。

有时你可以借用“列对齐”的方法来让代码易读。

让你的代码开起来像是表格一般。例如在wget数据库中，可用的命令行选项（有一百多项）这样列出：

```
commands[] = {
  ...
  { "timeout", NULL, cmd_spec_timeout },
  { "timestamping", &opt.timestamping, cmd_boolean },
  { "tries", &opt.ntry, cmd_number_inf },
  { "useproxy", &opt.use_proxy, cmd_boolean },
  { "useragent", NULL, cmd_spec_useragent },
  ...
}; 
```

这种方式使行这个列表很容易快读和从一列跳到另一列。

列的边提供了“可见的栏杆”，阅读起来很方便。这是个“让相似的代码看起来相似”的好例子。

### 选一个有意义的顺序，始终一致地使用它

在很多情况下，代码的顺序不会影响其正确性。例如，下面的5个变量定义可以写成任意的顺序：

```
details = request.POST.get('details')
location = request.POST.get('location')
phone = request.POST.get('phone')
email = request.POST.get('email')
url = request.POST.get('url') 
```

在这种情况下，不要随机地排序，把它们按有意义的方式排列会有帮助。下面是一些想法：

- 让变量的顺序与对应的HTML表单中＜input＞字段的顺序相匹配。
- 从“最重要”到“最不重要”排序。
- 按字母顺序排序。

### 把声明按块组织起来

我们的大脑很自然地会按照分组和层次结构来思考，因此你可以通过这样的组织方式来帮助读者快速地理解你的代码。

例如，下面是一个前端服务器的C++类，这里有它所有方法的声明：

```
class FrontendServer {
  public:
    FrontendServer();
    void ViewProfile(HttpRequest* request);
    void OpenDatabase(string location, string user);
    void SaveProfile(HttpRequest* request);
    string ExtractQueryParam(HttpRequest* request, string param);
    void ReplyOK(HttpRequest* request, string html);
    void FindFriends(HttpRequest* request);
    void ReplyNotFound(HttpRequest* request, string error);
    void CloseDatabase(string location);
    ~FrontendServer();
}; 
```

这不是很难看的代码，但可以肯定这样的布局不会对读者更快地理解所有的方法有什么帮助。不要把所有的方法都放到一个巨大的代码块中，应当按逻辑把它们分成组，像以下这样：

```
class FrontendServer {
  public:
    FrontendServer();
    ~FrontendServer();
    // Handlers
    void ViewProfile(HttpRequest* request);
    void SaveProfile(HttpRequest* request);
    void FindFriends(HttpRequest* request);
    // Request/Reply Utilities
    string ExtractQueryParam(HttpRequest* request, string param);
    void ReplyOK(HttpRequest* request, string html);
    void ReplyNotFound(HttpRequest* request, string error);
    // Database Helpers
    void OpenDatabase(string location, string user);
     void CloseDatabase(string location);
}; 
```

这个版本容易理解多了。它还更易读，尽管代码行数更多了。原因是你可以快速地找出4个高层次段落，然后在需要时再阅读每个段落的具体内容。

### 把代码分成“段落”

书面文字要分成段落是由于以下几个原因：

- 它是一种把相似的想法放在一起并与其他想法分开的方法。
- 它提供了可见的“脚印”，如果没有它，会很容易找不到你读到哪里了。
- 它便于段落之间的导航。

正因为这样的原因，下面的代码看起来效果很好。

```
def suggest_new_friends(user, email_password):
  # Get the user's friends' email addresses.
  friends = user.friends()
  friend_emails = set(f.email for f in friends)
  
  # Import all email addresses from this user's email account.
  contacts = import_contacts(user.email, email_password)
  contact_emails = set(c.email for c in contacts)
  
  # Find matching users that they aren't already friends with.
  non_friend_emails = contact_emails - friend_emails
  suggested_friends = User.objects.select(email__in=non_friend_emails)
  
  # Display these lists on the page.
  display['user'] = user
  display['friends'] = friends
  display['suggested_friends'] = suggested_friends
  return render("suggested_friends.html", display) 
```

正如书面文本，有很多种方法可以分开代码，程序员可能会对长一点或短一点的段落有不同的偏好。

### 个人风格与一致性

每个人都有他/她的代码风格。最知名的可能就是括号放哪里的争论了。

选择一种风格而非另一种，不会真的影响到代码的可读性。但如果把两种风格混在一起，就会对可读性有影响了。

> 一致的风格比“正确”的风格更重要。

总结

大家都愿意读有美感的代码。通过把代码用一致的、有意义的方式“格式化”，可以把代码变得更容易读，并且可以读得更快。
下面是讨论过的一些具体技巧：

- 如果多个代码块做相似的事情，尝试让它们有同样的剪影。
- 把代码按“列”对齐可以让代码更容易浏览。
- 如果在一段代码中提到A、B和C，那么不要在另一段中说B、C和A。选择一个有意义的顺序，并始终用这样的顺序。
- 用空行来把大块代码分成逻辑上的“段落”。

## 该写什么样的注释

本章关注怎么写注释

> 注释的目的是尽量帮助读者了解得和作者一样多。

我们把本章组织成以下几个部分：

- 了解什么不需要注释。
- 用代码记录你的思想。
- 站在读者的角度，去想象他们需要知道什么。

### 什么不需要注释

阅读注释会占用阅读真实代码的时间，并且每条注释都会占用屏幕上的空间。那么，它最好是物有所值的。

下面代码中所有的注释都是没有价值的：

```
// The class definition for Account
class Account {
  public:
    // Constructor
    Account();
    // Set the profit member to a new value
    void SetProfit(double profit);
    // Return the profit from this Account
     double GetProfit();
}; 
```

这些注释没有价值是因为它们并没有提供任何新的信息，也不能帮助读者更好地理解代码。

> 不要为那些从代码本身就能快速推断的事实写注释。

> 不要为了注释而注释

如果你想要在这里写条注释，它最好也能给出更多重要的细节.

> 不要给不好的名字加注释——应该把名字改好

注释不应用于粉饰不好的名字。

一个好的名字比一个好的注释更重要，因为在任何用到这个函数的地方都能看得到它。

> 好代码＞坏代码+好注释。

### 记录你的思想

很多好的注释仅通过“记录你的想法”就能得到，也就是那些你在写代码时有过的重要想法。

#### 加入“导演评论”

你应该在代码中也加入注释来记录你对代码有价值的见解。

例如

```
* * *
//这个类正在变得越来越乱
//也许我们应该建立一个'ResourceNode'子类来帮助整理
* * *
```

#### 为代码中的瑕疵写注释

代码始终在演进，并且在这过程中肯定会有瑕疵。不要不好意思把这些瑕疵记录下来。例如，当代码需要改进时：

```
* * *
//TODO：采用更快算法
* * *
```

有几种标记在程序员中很流行：

```
TODO -> Things to be done

FIXME -> Unwork code

HACK -> A not elegant solution

XXX! -> Dangerous

```

你的团队可能对于是否可以使用及何时使用这些标记有具体的规范。

重要的是你应该可以随时把代码将来应该如何改动的想法用注释记录下来。这种注释给读者带来对代码质量和当前状态的宝贵见解，甚至可能会给他们指出如何改进代码的方向。

#### 给常量加注释

当定义常量时，通常在常量背后都有一个关于它是什么或者为什么它是这个值的“故事”。

例如:

`NUM_THREADS = 8 # as long as it's >= 2 * num_processors, that's good enough.`

有些常量不需要注释，因为它们的名字本身已经很清楚（例如SECONDS_PER_DAY）。但是在我们的经验中，很多常量可以通过加注释得以改进。这不过是匆匆记下你在决定这个常量值时的想法而已。

### 站在读者的角度

一个通用的技术是想象你的代码对于外人来讲看起来是什么样子的，这个人并不像你那样熟悉你的项目。这个技术对于发现什么地方需要注释尤其有用。

#### 意料之中的提问

当别人读你的代码时，有些部分更可能让他们有这样的想法：“什么？为什么会这样？”你的工作就是要给这些部分加上注释。

#### 公布可能的陷阱

当为一个函数或者类写文档时，可以问自己这样的问题：“这段代码有什么出人意料的地方？会不会被误用？”基本上就是说你需要“未雨绸缪”，预料到人们使用你的代码时可能会遇到的问题。

#### 「全局观」注释

最难的事情之一就是理解“全局观”——类之间如何交互，数据如何在整个系统中流动，以及入口点在哪里。设计系统的人经常忘记给这些东西加注释，“只缘身在此山中”。

这正是那种应该包含在高级别注释中的信息。
下面是一个文件级别注释的简单例子：

//这个文件包含一些辅助函数，为我们的文件系统提供了更便利的接口

//它处理了文件权限及其他基本的细节。


不要对于写庞大的正式文档这种想法不知所措。几句精心选择的话比什么都没有强。

#### 总结性注释

就算在一个函数的内部，给“全局观”写注释也是个不错的主意。

这些注释同时也是对于函数所做事情的总结，因此读者可以在深入了解细节之前就能得到该函数的主旨。

注释应该说明“做什么”、“为什么”还是“怎么做”？

你可以做任何能帮助读者更容易理解代码的事。这可能也会包含对于“做什么”、“怎么做”或者“为什么”的注释（或者同时注释这三个方面）。

### 最后的思考——克服“作者心理阻滞”

写注释这件事拆成了几个简单的步骤：

1. 不管你心里想什么，先把它写下来。
2. 读一下这段注释，看看有没有什么地方可以改进。
3. 不断改进。

当你经常写注释，你就会发现步骤1所产生的注释变得越来越好，最后可能不再需要做任何修改了。并且通过早写注释和常写注释，你可以避免在最后要写一大堆注释这种令人不快的状况。

总结

注释的目的是帮助读者了解作者在写代码时已经知道的那些事情。本章介绍了如何发现所有的并不那么明显的信息块并且把它们写下来。

什么地方不需要注释：

- 能从代码本身中迅速地推断的事实。
- 用来粉饰烂代码（例如蹩脚的函数名）的“拐杖式注释”——应该把代码改好。

你应该记录下来的想法包括：

- 对于为什么代码写成这样而不是那样的内在理由（“指导性批注”）。
- 代码中的缺陷，使用像TODO：或者XXX：这样的标记。
- 常量背后的故事，为什么是这个值。



站在读者的立场上思考：

- 预料到代码中哪些部分会让读者说：“啊？”并且给它们加上注释。
- 为普通读者意料之外的行为加上注释。
- 在文件/类的级别上使用“全局观注释来解释所有的部分是如何一起工作的。
- 用注释来总结代码块，使读者不致迷失在细节中。


## 写出言简意赅的注释

本章关注： 写出信息密度高的注释

> 注释应当有很高的信息/空间率。

### 让注释保持紧凑

下面的例子是一个C++类型定义的注释：

```
// The int is the CategoryType.
// The first float in the inner pair is the 'score',
// the second is the 'weight'.
typedef hash_map<int, pair<float, float> > ScoreMap; 
```
可是为什么解释这个例子要用三行呢？用一行不就可以了吗？

`// CategoryType -> (score, weight)`

### 避免使用不明确的代词

如果使用了代词，那么最好让它没有二义性。

### 润色粗糙的句子

让注释更精确通常意味着让注释更紧凑。

`# Depending on whether we've already crawled this URL before, give it a different
priority.`

就不如这个版本。

`# Give higher priority to URLs we've never crawled before. `

### 精确地描述函数的行为

一个注释应该去精确地修饰函数的行为。

例如

```
// Count how many newline bytes ('\n') are in the file.
int CountLines(string filename) { ... } 
```
就修饰了行为而非名字。避免了函数行为被误解的情况。

### 用输入/输出例子来说明特别的情况

一个具有代表性的样例比得上大量言语。

例如

```
// Example: Strip("ab", "a") returns "b" 
```

### 声明代码的意图

尝试从更高的层次，比如人的层次来说明代码在干什么，而不是诉说具体代码的行为，这样更加易懂，简洁。

例如

```
// Display each price, from highest to lowestfor (list<Product>::reverse_iterator it = products.rbegin(); ... ) 
```
就比说从尾到头强多了。

### 『具名函数参数』的注释

Python运行调用函数时参数按照参数名传递。

而C++和Java等语言却不能这么干，于是，你可以让注释来达到类似的说明效果。

```
void Connect(int timeout, bool use_encryption) { ... }
// Call the function with commented parameters
Connect(/* timeout_ms = */ 10, /* use_encryption = */ false); 
```
 
 大多数函数不需要这样的注释，但这种方法可以方便（而且紧凑）地解释看上去难以理解的参数。
 
### 采用信息含量高的词
 
一旦你写了多年程序以后，你会发现有些普遍的问题和解决方案会重复出现。通常会有专门的词或短语来描述这种模式/定式。使用这些词会让你的注释更加紧凑。

设计模式就是干了这么一件事。把一些常见的代码片段或者思维模型命名，方便讨论他们。

如果你写了一堆代码，想想他们能不能被抽象成一种常见的术语。比如缓存层等等。

总结

本章是关于如何把更多的信息装入更小的空间里。下面是一些具体的提示：

- 当像"it"和"this"这样的代词可能指代多个事物时，避免使用它们。
- 尽量精确地描述函数的行为。
- 在注释中用精心挑选的输入/输出例子进行说明。
- 声明代码的高层次意图，而非明显的细节。
- 用嵌入的注释（如Function（/*arg=*/……））来解释难以理解的函数参数。
- 用含义丰富的词来使注释简洁。 


# 简化循环和逻辑

本章关注： 控制语句

第二部分将进一步深入讨论程序的“循环和逻辑”：控制流、逻辑表达式以及让你的代码正常运行的那些变量。和第一部分的要求一样，我们的目标是让代码中的这些部分容易理解。

## 把控制流变得易读

> 把条件、循环以及其他对控制流的改变做得越“自然”越好。运用一种方式使读者不用停下来重读你的代码。

### 条件语句中参数的顺序

一般倾向于左侧值为经常变化的，而右侧为不常变化的。

### if/else语句块的顺序

有些情况下有理由相信其中一种顺序比另一种好：

- 首先处理正逻辑而不是负逻辑的情况。例如，用if（debug）而不是if（！debug）。
- 先处理掉简单的情况。这种方式可能还会使得if和else在屏幕之内都可见，这很好。
- 先处理有趣的或者是可疑的情况。

有时这些倾向性之间会有冲突，那么你就要自己判断了。但在很多情况下这都会有明确的选择。

注意这些因素并且小心那些会使你的if/else顺序很别扭的情况。

### ?：条件表达式

> 相对于追求最小化代码行数，一个更好的度量方法是最小化人们理解它所需的时间。

默认情况下都用if/else。三目运算符?：只有在最简单的情况下使用。

### 避免do/while循环

> do语句是错误和困惑的来源……我倾向于把条件放在“前面我能看到的地方”。其结果是，我倾向于避免使用do语句。

### 从函数中提前返回

从函数中提前返回没有问题，而且常常很受欢迎。

想要单一出口点的一个动机是保证调用函数结尾的清理代码。但现代的编程语言为这种保证提供了更精细的方式。例如C++中的析构函数，Java等语言的try，catch语句。

### 臭名昭著的goto

如果只允许出现这一种goto的形式，goto不会成为什么大问题。

### 最小化嵌套

嵌套很深的代码很难以理解。

> 当你对代码做改动时，从全新的角度审视它，把它作为一个整体来看待。

#### 通过提早返回来减少嵌套

提早返回可以让多重嵌套化为当成嵌套。

#### 减少循环内的嵌套

一般来讲，continue语句让人很困惑，因为它让读者不能连续地阅读，就像循环中有goto语句一样。但是在这种情况中，循环中的每个迭代是相互独立的（这是一种"for each"循环），因此读者可以很容易地领悟到这里continue的意思就是“跳过该项”。

### 你能理解执行的流程吗

在实践中，编程语言和库的结构让代码在“幕后”运行，或者让流程难以理解。

例如线程、中断程序、异常等等。

这些结构中有些很有用，它们甚至可以让你的代码更具可读性，并且冗余更少。

但是作为程序员，有时候我们得意忘形了，于是用得太多了，却没有发现以后它会多么令人难以理解。（例如TryCatch...）并且，这些结构使得更难以跟踪bug。

关键是不要让代码中使用这些结构的比例太高。

总结

- 有几种方法可以让代码的控制流更易读。
- 在写一个比较时（while（bytes_expected＞bytes_received）），把改变的值写在左边并且把更稳定的值写在右边更好一些（while（bytes_received＜bytes_expected））。
- 你也可以重新排列if/else语句中的语句块。通常来讲，先处理正确的/简单的/有趣的情况。有时这些准则会冲突，但是当不冲突时，这是要遵循的经验法则。
- 某些编程结构，像三目运算符（:?）、do/while循环，以及goto经常会导致代码的可读性变差。最好不要使用它们，因为总是有更整洁的代替方式。
- 嵌套的代码块需要更加集中精力去理解。每层新的每层新的嵌套都需要读者把更多的上下文“压入栈”。应该把它们改写成更加“线性”的代码来避免深嵌套。
- 通常来讲提早返回可以减少嵌套并让代码整洁。“保护语句”（在函数顶部处理简单的情况时）尤其有用。


## 拆分超长的表达式

本章关注: 拆分表达式

> 把你的超长表达式拆分成更容易理解的小块。

### 用做解释的变量

拆分表达式最简单的方法就是引入一个额外的变量，让它来表示一个小一点的子表达式。这个额外的变量有时叫做“解释变量”，因为它可以帮助解释子表达式的含义。

下面是一个例子：

```
if line.split(':')[0].strip() == "root":  
	... 
```

下面是和上面同样的代码，但是现在有了一个解释变量。

```
username = line.split(':')[0].strip()
if username == "root":
  ... 
```

### 总结变量

即使一个表达式不需要解释（因为你可以看出它的含义），把它装入一个新变量中仍然有用。我们把它叫做总结变量，它的目的只是用一个短很多的名字来代替一大块代码，这个名字会更容易管理和思考。

例如，看看下面代码中的表达式。


```
if (request.user.id == document.owner_id) {
  // user can edit this document...
}
...
if (request.user.id != document.owner_id) {
  // document is read-only...
} 
```

这段代码中的主要概念是：“该用户拥有此文档吗？”这个概念可以通过增加一个总结变量来表达得更清楚。

```
final boolean user_owns_document = (request.user.id == document.owner_id);
if (user_owns_document) {
  // user can edit this document...
}
...
if (!user_owns_document) {
  // document is read-only...
} 
```

我们认为第二种代码更具可读性。

### 使用德摩根定理

如果你学过“电路”或者“逻辑”课，你应该还记得德摩根定理。对于一个布尔表达式，有两种等价的写法：

```
1) not (a or b or c) <=> (not a) and (not b) and (not c)
2) not (a and b and c) <=> (not a) or (not b) or (not c) 
```

这将帮助你让你少一层嵌套。

### 滥用短路逻辑

很多人会滥用短路逻辑，它们很方便，可是如果是为了减少行数，那么它们将会成为别人理解代码时的减速带。

> 要小心“智能”的小代码段——它们往往在以后会让别人读起来感到困惑。

### 拆分巨大的语句

本章是关于拆分独立的表达式的，但同样的技术也可以用来拆分大的语句。

例如，下面的JavaScript代码需要一次读很多东西：

```
var update_highlight = function (message_num) {
  if ($("#vote_value" + message_num).html() === "Up") {
    $("#thumbs_up" + message_num).addClass("highlighted");    
    $("#thumbs_down" + message_num).removeClass("highlighted");
  } else if ($("#vote_value" + message_num).html() === "Down") {
    $("#thumbs_up" + message_num).removeClass("highlighted");
    $("#thumbs_down" + message_num).addClass("highlighted");
  } else {
    $("#thumbs_up" + message_num).removeClass("highighted");
    $("#thumbs_down" + message_num).removeClass("highlighted");
  }
}; 
```

代码中的每个表达式并不是很长，但当把它们放在一起时，它们就形成了一条巨大的语句，迎面扑来。

幸运的是，其中很多表达式是一样的，这意味着可以把它们提取出来作为函数开头的总结变量（这同时也是一个DRY——Don't Repeat Yourself的例子）：

```
var update_highlight = function (message_num) {
  var thumbs_up = $("#thumbs_up" + message_num);
  var thumbs_down = $("#thumbs_down" + message_num);
  var vote_value = $("#vote_value" + message_num).html();
  var hi = "highlighted";
  
  if (vote_value === "Up") {
    thumbs_up.addClass(hi);
    thumbs_down.removeClass(hi);
  } else if (vote_value === "Down") {
    thumbs_up.removeClass(hi);
    thumbs_down.addClass(hi);
  } else {
    thumbs_up.removeClass(hi);
    thumbs_down.removeClass(hi);
  }
}; 
```

创建var hi="highlighted"严格来讲不是必需的，但鉴于这里有6次重复，有很多好处驱使我们这样做：

- 它帮助避免录入错误。（实际上，你是否注意到在第一个例子中，该字符串在第5种情况中被误写成"highhighted"？）
- 它进一步缩短了行的宽度，使代码更容易快速阅读。
- 如果类的名字需要改变，只需要改一个地方即可。

总结

很难思考巨大的表达式。本章给出了几种拆分表达式的方法，以便读者可以一段一段地消化。

一个简单的技术是引入“解释变量”来代表较长的子表达式。这种方式有三个好处：

- 它把巨大的表达式拆成小段。
- 它通过用简单的名字描述子表达式来让代码文档化。
- 它帮助读者识别代码中的主要概念。

另一个技术是用德摩根定理来操作逻辑表达式——这个技术有时可以把布尔表达式用更整洁的方式重写（例如if（！（a ＆＆！b））变成if（！a||b））。

本章给出了一个，把一个复杂的逻辑条件拆分成小的语句的例子，就像"if（a＜b）……"。实际上，在本章所有改进过的示例代码中，所有的if语句内都没有超过两个值。这是理想理想情况。可能不是总能做到这样——有时需要把问题“反向”或者考虑目标的对立面。

最后，尽管本章是关于拆分独立的表达式的，同样，这些技术也常应用于大的代码块。所以，你可以在任何见到复杂逻辑的地方大胆地去拆分它们。

## 变量与可读性

本章关注: 变量

在本章里，你会看到对于变量的草率运用如何让程序更难理解。确切地说，我们会讨论三个问题：

1. 变量越多，就越难全部跟踪它们的动向。
2. 变量的作用域越大，就需要跟踪它的动向越久。
3. 变量改变得越频繁，就越难以跟踪它的当前值。

### 减少变量

**应该减少的变量 --  没有价值的临时变量**

通过让代码提前返回，我们不再需要临时变量，并且大幅简化了代码。

通常来讲，“速战速决”是一个好的策略。

减少控制流变量。

控制流变量通常可以通过更好地运用结构化编程而消除。

如果有多个嵌套循环，一个简单的break根本不够怎办呢？在这种更复杂的情况下，解决方案通常包括把代码挪到一个新函数中（要么是循环中的代码，要么是整个循环）。

### 缩小变量的作用域

我们都听过“避免全局变量”这条建议。这是一条好的建议，因为很难跟踪这些全局变量在哪里以及如何使用它们。并且通过“命名空间污染”（名字太多容易与局部变量冲突），代码可能会意外地改变全局变量的值，虽然本来的目的是使用局部变量，或者反过来也有同样的效果。

实际上，让所有的变量都“缩小作用域”是一个好主意，并非只是针对全局变量。

> 让你的变量对尽量少的代码行可见。

很多编程语言提供了多重作用域/访问级别，包括模块、类、函数以及语句块作用域。通常越严格的访问控制越好，因为这意味着该变量对更少的代码行“可见”。

为什么要这么做？因为这样有效地减少了读者同时需要考虑的变量个数。如果你能把所有的变量作用域都减半，那么这就意味着同时需要思考的变量个数平均来讲是原来的一半。

从某种意义上来讲，类的成员变量就像是在该类的内部世界中的“小型全局变量”。尤其对大的类来讲，很难跟踪所有的成员变量以及哪个方法修改了哪个变量。这样的小型全局变量越少越好。

另一个对类成员访问进行约束的方法是“尽量使方法变成静态的”。静态方法是让读者知道“这几行代码与那些变量无关”的好办法。

或者还有一种方式是“把大的类拆分成小一些的类”。

把大文件拆分成小文件，或者把大函数拆分成小函数也是同样的道理。这么做的一个重要的动机就是数据（即变量）分离。

### 只写一次的变量更好

不断变化的变量更难让人理解。跟踪这种变量的值更有难度。

要解决这种问题，我们有一个听起来怪怪的建议：只写一次的变量更好。

『永久固定”』的变量更容易思考。

> 操作一个变量的地方越多，越难确定它的当前值。

总结

本章是关于程序中的变量是如何快速累积而变得难以跟踪的。你可以通过减少变量的数量和让它们尽量“轻量级”来让代码更有可读性。具体有：

- 减少变量，即那些妨碍的变量。我们给出了几个例子来演示如何通过立刻处理结果来消除“中间结果”变量。
- 减小每个变量的作用域，越小越好。把变量移到一个有最少代码可以看到它的地方。眼不见，心不烦。
- 只写一次的变量更好。那些只设置一次值的变量（或者const、final、常量）使得代码更容易理解。

# 重新组织代码

本章关注：组织代码

该部分会讨论可以在函数级别对代码做的更大的改动。具体来讲，我们会讲到三种组织代码的方法：

- 抽取出那些与程序主要目的“不相关的子问题”。
- 重新组织代码使它一次只做一件事情。
- 先用自然语言描述代码，然后用这个描述来帮助你找到更整洁的解决方案。



最后，我们会讨论你可以把代码完全移除或者一开始就避免写它的那些情况——唯一可称为改进代码可读性的最佳方法。

## 抽取不相关的子问题

本章关注: 不相关的子逻辑

1. 看看某个函数或代码块，问问你自己：这段代码高层次的目标是什么？

2. 对于每一行代码，问一下：它是直接为了目标而工作吗？这段代码高层次的目标是什么呢？

3. 如果足够的行数在解决不相关的子问题，抽取代码到独立的函数中。

### 纯工具代码

有一组核心任务大多数程序都会做，例如操作字符串、使用哈希表以及读/写文件。

通常，这些“基本工具”是由编程语言中内置的库来实现的。

但有时你要自己来填充这中间的空白。

通常来讲，如果你在想：“我希望我们的库里有XYZ()函数”，那么就写一个！（如果它还不存在的话）经过一段时间，你会建立起一组不错的工具代码，后者可以应用于多个项目。

### 创建大量通用代码

通用代码很好，因为“它完全地从项目的其他部分中解耦出来”。像这样的代码容易开发，容易测试，并且容易理解。

从你的项目中拆分出越多的独立库越多越好，因为你代码的其他部分会更小而且更容易思考。

### 项目专有的功能

上述讲解对于项目专有代码也是如此。

### 简化已有接口

人人都爱提供整洁接口的库——那种参数少，不需要很多设置并且通常只需要花一点工夫就可以使用的库。它让你的代码看起来优雅：简单而又强大。

但如果你所用的接口并不整洁，你还是可以创建自己整洁的“包装”函数。

这里我们学到的是“你永远都不要安于使用不理想的接口”。你总是可以创建你自己的包装函数来隐藏接口的粗陋细节，让它不再成为你的阻碍。

例如Android中Camera的API就是灾难。所以为什么不做个Wrapper呢？

### 按需重塑接口

程序中很多代码在那里只是为了支持其他代码——例如，为函数设置输入或者对输出做后期处理。这些“粘附”代码常常和程序的实际逻辑没有任何关系。这种传统的代码是抽取到独立函数的最好机会。

### 过犹不及

像我们在本章的开头所说的那样，我们的目标是“积极地发现和抽取不相关的子问题”。我们说“积极地”是因为大多数程序员不够积极。但也可能会过于积极，导致过犹不及。

为代码增加一个函数存在一个小的（却有形的）可读性代价。

总结

对本章一个简单的总结就是“把一般代码和项目专有的代码分开”。其结果是，大部分代码都是一般代码。通过建立一大组库和辅助函数来解决一般问题，剩下的只是让你的程序与众不同的核心部分。
这个技巧有帮助的原因是它使程序员关注小而定义良好的问题，这些问题已经同项目的其他部分脱离。其结果是，对于这些子问题的解决方案倾向于更加完整和正确。你也可以在以后重用它们。

## 一次只做一件事

同时在做几件事的代码很难理解。一个代码块可能初始化对象，清除数据，解析输入，然后应用业务逻辑，所有这些都同时进行。如果所有这些代码都纠缠在一起，对于每个“任务”都很难靠其自身来帮你理解它从哪里开始，到哪里结束。

> 应该把代码组织得一次只做一件事情。


下面是用于使代码“一次只做一件事”所用到的流程：

1. 列出代码所做的所有“任务”。这里的“任务”没有很严格的定义——它可以小得如“确保这个对象有效”，或者含糊得如“遍历树中所有结点”。
2. 尽量把这件任务拆分到不同的函数中，或者至少是代码中不同的段落中。

总结

本章给出了一个组织代码的简单技巧：一次只做一件事情。

如果你有很难读的代码，尝试把它所做的所有任务列出来。其中一些任务可以很容易地变成单独的函数（或类）。其他的可以简单地成为一个函数中的逻辑“段落”。具体如何拆分这些任务没有它们已经分开这个事实那样重要。难的是要准确地描述你的程序所做的所有这些小事情。

## 把想法变成代码

> 如果你用中文都无法写出来，你又怎么用代码写呢？

> 如果你不能把一件事解释给你祖母听的话说明你还没有真正理解它。

当把一件复杂的事向别人解释时，那些小细节很容易就会让他们迷惑。把一个想法用“自然语言”解释是个很有价值的能力，因为这样其他知识没有你这么渊博的人才可以理解它。这需要把一个想法精炼成最重要的概念。这样做不仅帮助他人理解，而且也帮助你自己把这个想法想得更清晰。

在你把代码“展示”给读者时也应使用同样的技巧。我们接受代码是你解释程序所做事情的主要手段这一关点。所以代码应当用“自然语言”编写。

### 清楚地描述逻辑

```
$is_admin = is_admin_request();
if ($document) {
  if (!$is_admin && ($document['username'] != $_SESSION['username'])) {
    return not_authorized();
  }
} else {
  if (!$is_admin) {
    return not_authorized();
  } 
}
// continue rendering the page ... 
```

这段代码中有相当多的逻辑。像你在本书第二部分所读到的，这种大的逻辑树不容易理解。这些代码中的逻辑可以简化，但是怎么做呢？让我们从用自然语言描述这个逻辑开始：
授权你有两种方式：
1.你是管理员
2.你拥有当前文档（如果有当前文档的话）
否则，无法授权你。
下面是受这段描述启发写出的不同方案：

```
if (is_admin_request()) {
  // authorized
} elseif ($document && ($document['username'] == $_SESSION['username'])) {
  // authorized
} else {
  return not_authorized();
}

// continue rendering the page ... 
157
if (is_admin_request()) {
  // authorized
} elseif ($document && ($document['username'] == $_SESSION['username'])) {
  // authorized
} else {
  return not_authorized();
}

// continue rendering the page ... 
```

### 了解函数库是有帮助的

编写精练代码的一部分工作是了解你的库提供了什么。

总结

本章讨论了一个简单的技巧，用自然语言描述程序然后用这个描述来帮助你写出更自然的代码。这个技巧出人意料地简单，但很强大。看到你在描述中所用的词和短语还可以帮助你发现哪些子问题可以拆分出来。
但是这个“用自然语言说事情”的过程不仅可以用于写代码。例如，某个大学计算机实验室的规定声称当有学生需要别人帮它调试程序时，他首先要对房间角落的一只专用的泰迪熊解释他遇到的问题。令人惊讶的是，仅仅通过大声把问题描述出来，往往就能帮这个学生找到解决的办法。这个技巧叫做“橡皮鸭技术”。
另一个看待这个问题的角度是：如果你不能把问题说明白或者用词语来做设计，估计是缺少了什么东西或者什么东西缺少定义。把一个问题或想法）变成语言真的可以让它更具体。

## 少写代码

本章关注: 重用

知道什么时候不写代码可能对于一个程序员来讲是他所要学习的最重要的技巧。你所写的每一行代码都是要测试和维护的。通过重用库或者减少功能，你可以节省时间并且让你的代码库保持精简节约。

> 最好读的代码就是没有代码。

### 别费神实现那个功能——你不会需要它

程序员倾向于高估有多少功能真的对于他们的项目来讲是必不可少的。很多功能结果没有完成，或者没有用到，也可能只是让程序更复杂。

程序员还倾向于低估实现一个功能所要花的工夫。我们乐观地估计了实现一个粗糙原型所要花的时间，但是忘记了在将来代码库的维护、文件以及后增的“重量”所带来的额外时间。

#### 质疑和拆分你的需求

不是所有的程序都需要运行得快，100%准确，并且能处理所有的输入。如果你真的仔细检查你的需求，有时你可以把它削减成一个简单的问题，只需要较少的代码。

### 保持小代码库


最好的解决办法就是“让你的代码库越小，越轻量级越好”，就算你的项目在增长。

那么你就要：

- 创建越多越好的“工具”代码来减少重复代码（见第10章）。
- 减少无用代码或没有用的功能（见下图）。
- 让你的项目保持分开的子项目状态。
- 总的来说，要小心代码的“重量”。让它保持又轻又灵。

### 熟悉你周边的库

很多时候，程序员就是不知道现有的库可以解决他们的问题。或者有时，它们忘了库可以做什么。知道你的库能做什么以便你可以使用它，这一点很重要。

这里有一条比较中肯的建议：每隔一段时间，花15分钟来阅读标准库中的所有函数/模块/类型的名字。这包括C++标准模板库（STL）、Java API、Python内置的模块以及其他内容。

这样做的目的不是记住整个库。这只是为了了解有什么可以用的，以便下次你写新代码时会想：“等一下，这个听起来和我在API中见到的东西有点像……”我们相信提前做这种准备很快就会得到回报，起码因为你会更倾向于使用库了。

#### 为什么重用库有这么大的好处

在一个成熟的库中，每一行代码都代表相当大量的设计、调试、重写、文档、优化和测试。任何经受了这样达尔文进化过程一样的代码行就是很有价值的。这就是为什么重用库有这么大的好处，不仅节省时间，还少写了代码。

总结

冒险、兴奋——绝地武士追求的并不是这些。
——尤达大师

本章是关于写越少代码越好的。每行新的代码都需要测试、写文档和维护。另外，代码库中的代码越多，它就越“重”，而且在其上开发就越难。

你可以通过以下方法避免编写新代码：

- 从项目中消除不必要的功能，不要过度设计。
- 重新考虑需求，解决版本最简单的问题，只要能完成工作就行。
- 经常性地通读标准库的整个API，保持对它们的熟悉程度。

# 精选话题

## 测试与可读性

> 测试应当具有可读性，以便其他程序员可以舒服地改变或者增加测试。

### 使这个测试更可读

应该封装代码实现细节，测试重要的不是实现。这对测试可读性很重要。

### 创建最小的测试声明

大多数测试的基本内容都能精练成“对于这样的输入/情形，期望有这样的行为/输出”。并且很多时候这个目的可以用一行代码来表达。这除了让代码紧凑而又易读，让测试的表述保持很短还会让增加测试变得很简单。

### 实现定制的『微语言』

般来讲，定义一种定制的微语言可能是一种占用很少的空间来表达大量信息的强大方法。

### 让错误消息具有可读性

应该手工打造或者用库让你的测试错误信息更加易读。

### 选择好的测试输入

测试用例也应该很易读。

> 基本原则是，你应当选择一组最简单的输入，它能完整地使用被测代码。


> 又简单又能完成工作的测试值更好。

对于大的、不切实际的输入进行测试当然是有价值的。


### 一个功能的多个测试
与其建立单个“完美”输入来完整地执行你的代码，不如写多个小测试，后者往往会更容易、更有效并且更有可读性。

每个测试都应把代码推往某一个方向，尝试找到某种bug。

如果要非常地彻底，还可以写更多的测试。有分开的测试用例还可以使下一个负责代码相关工作的人更轻松。如果有人不小心引入了一个bug，测试的失败会指向那个具体的失败测试用例。

### 为测试函数命名

一种构造好的测试函数名的简单方式是把这些信息拼接在一起，可能再加上一个"Test_"前缀。

依照测试的精细程度不同，你可能会考虑为测试的每种情形写一个单独的测试函数。可以使用`Test_＜FunctionName＞_＜Situation＞（）`这样的格式。

这里不要怕名字太长或者太繁琐。

### 对测试较好的开发方式

在所有的把一个程序拆分成类和方法的途径中，解耦合最好的那一个往往就是最容易测试的那个。


另一方面，假设你的程序内部联系很强，在类与类之间有很多方法的调用，并且所有的方法都有很多参数。不仅这个程序会有难以理解的代码，而且测试代码也会很难看，并且既难读又难写。

有很多“外部”组件（需要初始化的全局变量、需要加载的库或者配置文件等）对写测试来讲也是很讨厌的。

### 走得太远

- 牺牲真实代码的可读性，只是为了使能测试。把真实代码设计得具有可测试性，这应该是个双赢的局面：真实的代码变得简单而且低耦合，并且也更容易为它写测试。但是如果你仅仅是为了测试它而不得不在真实代码中插入很多难看的塞子，那肯定有什么地方不对了。
- 着迷于100%的测试覆盖率。测试你代码的前面90%通常要比那后面的10%所花的工夫少。后面那10%包括用户接口或者很难出现的错误情况，其中bug的代价并不高，花工夫来测试它们并不值得。



事实上你永远也不会达到100%的测试覆盖率。如果不是因为漏掉的bug，也可能是因为漏掉的功能或者你没想到说明书应该改一改。

根据你的bug的成本不同，对于你花在测试代码上的范围。如果你在建一个网站原型，可能写任何测试都是不值得的。另一方面，如果你在为一架飞船或者一台医用设备编写控制器，测试可能是你的重点。

- 让测试成为产品开发的阻碍。我们曾见过这样的情形，测试，本应只是项目的一个方面，却主导了整个项目。测试成了要敬畏的上帝，程序员只是走走这些仪式和过场，没有意识到他们在工程上宝贵的时间花在别的地方可能会更好。

总结

在测试代码中，可读性仍然很重要。如果测试的可读性很好，其结果是它们也会变得很容易写，因此大家会写更多的测试。并且，如果你把事实代码设计得容易测试，代码的整个设计会变得更好。

以下是如何改进测试的几个具体要点：

- 每个测试的最高一层应该越简明越好。最好每个测试的输入/输出可以用一行代码来描述。
- 如果测试失败了，它所发出的错误消息应该能让你容易跟踪并修正这个bug。
- 使用最简单的并且能够完整运用代码的测试输入。
- 给测试函数取一个有完整描述性的名字，以使每个测试所测到的东西很明确。不要用Test1（），而用像Test_＜FunctionName＞_＜Situation＞这样的名字。



最重要的是要使它易于改动和增加新的测试。


---