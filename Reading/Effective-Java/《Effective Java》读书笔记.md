title: 《Effective Java》读书笔记
tag: [Effective, Java, 读书, 笔记, 代码]
category: 读书
------

# 前言

Effective Series包含很多书籍。其大多都很经典。而《Effective Java》也是如此。作为进阶Java的好书之一，当然是必读啦。


# 笔记

## 创建和销毁对象

### 考虑用静态工厂方法替代构造器

静态工厂方法相比于构造器有诸多优势。

1. 它们有名称。命名模式使得代码语义更加清晰。
2. 不必在每次调用它们的时候都创建一个新的对象。 -- 也就意味着可以可以缓存结果。
3. 可以返回原返回类型的任何子类型对象
4. 在创建参数化类型实例的时候，它们使代码变得更加简洁。

当然也有些许缺点。

1. 类如果不含公有的或者受保护的构造器，就不能被子类化。
2. 它们与其他的静态方法实际上没有任何区别。

所以我们一般用名称区别它们和其他静态方法。

1. valueOf
2. of
3. getInstance
4. newInstance
5. getType
6. newType

### 遇到多个构造器参数时要考虑用构建器

文中讲到了两种常用的模式来实现构造器的可选参数功能。

1. 重叠构造器模式  -- 这种模式在Java和C++中都有优化 -- 重叠构造器模式可行，但是当有很多参数的时候，客户端代码会很难编写，并且仍然较难以阅读。

2. 第二种方式是Builder模式，这种模式的好处就在于通过代理类来帮助实现构建过程，清晰，易读。

### 用私有构造器或者枚举类型强化Singleton属性

本小节讲解单例模式，还没有我第一篇博文深入，所以可以不看了。

### 通过私有构造器强化不可实例化的能力

可能有人会想通过AbstractClass也可以达到不可实例化的作用。实际上，这会造成此类被误认为是可被子类化的能力，是为继承而设计的。所以并不合适。

所以还是私有化构造器比较合理。

### 避免创建不必要的对象

文中使用了几个例子作演示：

1. 使用字符串字面量而不是字符串构造器新建字符串对象，使其重用已用字符串。
2. 使用静态工厂方法或构造器的不可变类，以避免创建不必要的对象。
3. 也可以重用那些等价不可变的对象。
4. 适配器可以被重用。
5. 优先使用基本类型而不是装箱基本类型。
6. 小对象的创建和回收其实是非常廉价的。
7. 维护自己的对象池来避免创建对象并不是一个好的做法。


### 消除过期的对象引用

一旦对象引用已经过期，只需清空这些引用即可。

清空过期引用的另一个好处是，如果它们以后又被错误地解除引用，程序就会立即抛出NullPointerException异常，而不是悄悄地错误运行下去。

如果类似自己管理内存，程序员就应该警惕内存泄露问题。
 
内存泄露的另一个常见来源是缓存。缓存验证问题一直是一个难题。LRU是常用的实现缓存的一种方式。
 
内存泄露的第三个常见来源是监听器和其他回调。 这个做过Android开发的一定很清楚。
 
###  避免使用终结方法

终结方法通常是不可预测的，也是危险的，一般而言下是不必要的。

终结方法的缺点在于不能保证会及时地执行。

Java语言规范不仅不保证终结方法会被及时的执行，而且根本就不保证它们会被执行。

使用终结方法有一个非常严重的性能损失。

替代方案是应该是写一个显式的终止方法。比如IO对象的close方法等等。

显式的终止方法通常与try-finally结构结合起来使用，以确保及时终止。

终结方法有合法用途。

当对象的所有者忘记调用前面段落中建议的显示终止方法时，终结方法可以充当『安全网』。

为了终止非关键的本地资源。

如果子类实现者覆盖了超类的终结方法，但是忘了手工调用超类的终结方法，那么超类的终结方法将永远不会调用。

## 对于所有对象都通用的方法

### 覆盖equals时请遵守通用约定

类的每个实例本质上都是唯一的。

不关心类是否提供了『逻辑相等』的测试功能。

超类已经覆盖了equals，从超类继承过来的行为对于子类也是合适的。

类的私有的域或者包机私有的，可以确定它的equals方法永远不会被调用。

equals方法实现了等价关系：

- 自反性
- 对称性
- 传递性
- 一致性
- 非空心

得出了以下实现高质量equals方法的诀窍：

1. 使用==操作符检查『参数是否为这个对象的引用』。
2. 使用instance操作符检查『参数是否为正确的类型』。
3. 把参数转换成正确的类型。
4. 如果该类中的每个『关键』域，检查参数中的域是否与该对象中对应的域相匹配。
5. 当你编写完成了equals方法后应该问自己三个问题：它是否是对称的、传递的、一致的？

下面是最后的一些告诫：

- 覆盖equals时总要覆盖hashCode
- 不要企图让equals方法过于智能 -- do one thing and do it well.
- 不要将equals声明中的Object对象替换为其他的类型

### 覆盖equals时总要覆盖hashCode

IntelliJ大法好。

hashCode的实现有一套惯用规则。感兴趣的去查阅相关资料，这里就不细讲了。

### 始终要覆盖toString

在实际应用中，toString方法应该返回对象中包含的所有值得关注的信息。

无论你是否决定指定格式，都应该在文档中明确地表明你的意图。

无论是否指定格式，都为toString返回值中包含的所有信息，提供一种编程式的访问途径。

### 谨慎的覆盖clone

Cloneable的目的是作为对象的一个mixing借口，表明这样的对象允许克隆。遗憾的是，它并没有成功地达到这个目的。其主要的缺陷在于，它缺少一个clone方法，Object的clone方法是受保护的。

他决定了Object中受保护的clone方法实现的行为：如果一个类实现了Cloneable，Object的clone方法就返回该对象的clone方法实现的行为。

从6.0版本开始，Cloneable接口并没有清楚地指明，一个类在实现这个接口时应该承担哪些责任。

所有实现了Cloneable接口的类都应该用一个公有的方法覆盖clone。此公有方法首先调用super.clone，然后修正任何需要修正的域。

Clone able具有诸多问题，可以肯定地说，其他的接口都不应该去拓展这个接口，为了继承和设计的类更不应该实现这个接口。

### 考虑实现Comparable接口

一旦类实现了Comparable接口，它就可以跟很多泛型算法以及依赖于该接口的集合实现进行协作。

## 类和接口

### 使类和成员的可访问性最小化

要区别设计良好的模块与设计不好的模块，最重要的因素在于，这个模块对于外部的其他模块而言，是否隐藏其内部数据和其他实现细节。

尽可能地是每个类或者成员不能被外界访问。

对于顶层的内和接口，只有两种可能的访问级别：包级私有的和公有的。

如果一个包级私有的顶层类只是在某个类的内部被用到，就应该考虑使它成为唯一使用它的那个类的私有嵌套类。

当你仔细地设计了类的公有API之后，可能觉得应该把其他的成员都变成私有的。其实，只有当同一个包内的另一个类真正需要访问一个成员的时候，你才应该删除私有限制符，使该成员变成包级私有的。

对于公有类的成员，当访问级别从包级私有变成保护级别时，会大大增强可访问性。

为了便于测试，你可以试着使类、接口或者成员变得更容易访问。

静态域、实例域决不能是公有的。

类具有公有的静态final数组域，或者返回这种域的访问方法，这几乎总是错误的。

### 在公有类中使用访问方法而非公有域

如果类可以在它所在的包的外部进行访问，就提供访问方法。

如果类似包级私有的，或者是私有的嵌套类，直接暴露它的数据域没有本质的错误。

### 使可变性最小化

为了使类变成不可变，要遵循下面五条规则：

1. 不要提供任何会修改对象状态的方法。

2. 保证类不会被拓展。

3. 使所有域都是final的。

4. 使所有的域都是private的。

5. 确保对于任何可变组件的互斥访问。

不可变类本质上是线程安全的，它们不要求同步。

不仅可以共享不可变对象，甚至可以共享它们的内部信息。

不可变对象为其他对象提供了大量的构件。

不可变对象唯一的缺点是，对于每个不同的值都需要一个单独的对象。

坚决不要为每个get方法编写一个对应的set方法。除非有很好的理由要让类成为可变的类，否则就应该是不可变的。

如果类不能被做成不可变的，仍然应该尽可能地限制它的可变性。

### 复合优先于继承

与方法调用不同的是，继承打破了封装性。

导致子类脆弱的一个相关的原因是，它们的超类在后续的发行版本中可以获得新的方法。

然后介绍了Decorator Model。。。

如果在适合于使用复合的地方使用了继承，则会不必要地暴露实现细节。

### 要么为继承而设计，并提供文档说明，要么就禁止继承

首先，该类的文档必须精确地描述覆盖每个方法所带来的影响。

按惯例，如果方法调用到了可覆盖的方法，在它的文档注释的末尾应该包含关于这些调用的描述信息。

类必须通过某种形式提供适当的钩子，以便能够进入到它的内部工作流程中，这种形式可以是精心选择的受保护的方法或域。

对于为了继承而设计的类，唯一的测试方法就是编写子类。

构造器决不能调用可被覆盖的方法。

为了继承而设计的类，对这个类会有一些实质性的限制。

这个问题的最佳解决方案是，对于那些并非为了安全地进行子类化而设计和编写文档的类，要禁止子类化。

### 接口优先于抽象类

现有的类可以很容易被更新，以实现新的接口。

接口是定义mixin的理想类型。

接口允许我们构造非层次结构的类型框架。

通过对你导出的每个重要接口都提供一个抽象的骨架实现类，把接口和抽象类的有点结合起来。

骨架实现的美妙之处在于，它们为抽象类提供了实现上的帮助，但又不强加『抽象类被用作类型定义时』所特有的严格限制。

使用抽象类来定义允许多个实现的类型，与使用借口而相比有一个明显的优势：抽象类的演变比接口的演变要容易得多。这一点在8.0以上版本因为default interface method的出现而不再成立。

### 接口只用于定义类型

常量接口模式对接口的不良使用。

接口应该只被用来定义类型，它们不应该用来导出常量。


### 类层次优于标签类

标签类过于冗长、容易出错、并且效率低下。---我以前上Java课老师就写出了ConsumerOrProvider这种类。。。

标签类真是内层次的一种简单的仿效。

类层次避免了所有问题，还带来了其他红利：它们可以用来反映类型之间本质上的层次关系，有助于增强灵活性，并进行更好的编译时类型检查。

### 用函数对象表示策略

这条款主要说明函数对象在实现Strategy Model上的好处。相信这点熟悉Java的童鞋应该都不难理解。就JMP吧。

### 优先考虑静态成员类

这条款有点像是介绍内部类的一章。这里略过介绍语法的部分。

静态成员内的一种常见用法是作为公有的辅助类，仅当与它的外部类一起使用时才有意义。

如果声明成员类不要求访问外围实例，就要始终把static修饰符放在它的声明中。

静态内部类的缺点就是会导致GC无法回收的问题。

## 泛型

### 请不要在新代码中使用原生态类型

如果使用原生态类型，就失掉了泛型在安全性和表述性方面的所有优势。

如果使用List这样的原生态类型，就会失掉类型安全性，但是如果使用像List<Object>这样的参数化类型，则不会。

### 消除非受检警告

要尽可能地消除每一个非受检警告。

如果无法消除警告，同时可以证明引起警告的代码是类型安全的，可以用一个@SuppressWarning("unchecked")注解来禁止这条警告。

每当使用SuppressWarnings("unchecked")注解事，都要添加一条注释，说明为什么这么做是安全的。

### 列表优先于数组

由于类型擦除，数组和泛型不能很好地混合使用。

数组是具体化的，数组在运行时才知道并检查它们的元素类型约束。

数组不能泛型是Scala的发明人当时的一个偷懒行为，严重BS。。。

当你得到泛型数组创建错误时，最好的解决方法通常是优先使用集合类型而不是数组类型。

### 优先考虑泛型

使用泛型比使用需要在客户端代码中进行转换的类型来得更加安全，也更加容易。

### 优先考虑泛型方法

静态工具方法尤其适合于泛型化。

泛型方法的一个显著特性是，无需明确指定类型参数的值，不像调用泛型构造器的时候必须指定的。

总而言之，泛型方法就像泛型一样，使用起来比要求客户端转换输入参数并返回值的方法来得更加安全，也更加容易。


### 利用有限制通配符来提升API的灵活性

为了获得最大限度的灵活性，要在表示生产者或者消费者的输入参数上使用通配符类型。

PECS表达式： producer-extends，consumer-super。如果参数化类型表示一个T生产者，就使用<？ extends T>；如果它表示一个T消费者，就是用<？ super T>。

不要用通配符类型作为返回类型。

如果类的用户必须考虑通配符类型，类的API或许就会出错。

在API中使用通配符类型虽然比较需要技巧，但是使API变得灵活的多。如果编写的是将被广泛使用的类库，则一定要适当地利用通配符类型。记住基本的原则:producer-extends，consumer-super。还要记住所有的comparable和comparator都是消费者。

### 优先考虑类型安全的异构容器

泛型最常用于集合，如Set和Map，已经单元素的容器，如ThreadLocal和AtomicReference。

集合API说明了泛型的一般用法，限制你每个容器只能有固定数目的类型参数。

## 枚举和注解

### 用enum代替int常量

Java的枚举本质上是int值。

Java枚举类型背后的基本想法非常简单：它们就是通过公有的静态final域为每个枚举常量导出实例的类。

枚举提供了编译时的类型安全。

除了完善了int枚举模式的不足之外，枚举类型还允许添加任意的方法和域，并实现任意的接口。

如果一个枚举具有普遍适用性，它就应该成为一个顶层类。如果被用在一个特定的顶层类中，它就应该成为该顶层类的一个成员类。

使用strategy model解耦枚举实例和其方法的关系。

一般来说，枚举会优先使用comparator而非int常量。

### 用实数域代替序数

永远不要根据枚举的序数导出与它关联的值，而是要将它保存在一个实例域中。

### 用EnumSet代替位域

正是因为枚举类型要用在集合中，所以没有理由用位域来表示它。EnumSet类集位域的简洁和性能优势及第30条中所述的枚举类型的优点于一身。

### 用EnumMap替代序数索引

EnumMap能更好的描述Key，Value的映射关系。使程序更简短、清楚、安全。

最好不要用序数来索引数组，而要使用EnumMap。

### 用接口模拟可伸缩的枚举

想要让enum具有scalability，可以使用接口来实现。

在可以使用基础操作的任何地方，都可以使用新的操作，只要是API是被写成采用接口类型而非实现。

不仅可以在任何需要『基本枚举』的地方单独传递一个『拓展枚举』的实例，而且除了那些基本类型的元素之外，还可以传递完整的拓展枚举类型，并使用它的元素。

虽然无法编写可拓展的枚举类型，却可以通过编写接口以及实现该接口的基础枚举类型，对它进行模拟。

### 注解优先于命名模式

命名模式的缺点：

1. 文字编写错误会导致失败。。。
2. 无法确保它们只用于相应的程序元素上。
3. 它们没有提供将参数值与程序元素关联起来的好方法。

注解解决了所有问题。

所有的程序员都应该使用Java平台所提供的预定义的注解类型。

### 坚持使用Override注解

这条大家都应该遵守的挺好的。(感谢IDE)

好处当然是能获得编译期的保证。


###用标记接口定义类型

标记接口是没有包含方法声明的接口，而只是指明一个类实现了某种属性的接口。

标记接口有两点胜于标记注解：

1. 标记接口定义的类型是又被标记类的实例定义的。标记注解没有定义这样的类型。
2. 它们可以被更加精确地进行锁定。

标记注解胜于标记接口之处：

1. 它可以通过默认的方式添加一个或者多个注解类型元素，给已被使用的注解类型添加更多的信息。
2. 标记注解在那些支持注解作为编程元素之一的框架中具有一致性。

什么时候应该使用标记注解，什么时候应该使用标记接口？

1. 如果标记是应用到任何程序元素而不是类或者接口，就必须使用注解。
2. 如果不是，则如果要编写一个或者多个只接受有这种标记的方法，优先使用标记接口。
3. 如果不是，则如果要永远限制这个标记只用于特殊的元素，最好将标记定义成该接口的一个子接口。
4. 如果不是，使用注解。

## 方法

### 检查参数的有效性

绝大多数方法和构造器对于传递给它们的参数值都会有某些限制。你应该在文档中清楚地指明所有这些限制，并且在方法体的开头处检查参数，以强制施加这些限制。

如果传递无效的参数值给方法，这个方法在执行之前先对参数进行了检查，那么它很快就会失败，并且清楚地出现适当的异常。

对于公有的方法，要用Javadoc的@throws标签在文档中说明违反参数值限制时会抛出的异常。

对于未被导出的方法，作为包的创建者，你可以控制这个方法将在哪些情况下被调用，因此你可以，也应该确保只将有效的参数值传递进来。

对于有些参数，方法本身没有用到，却被保存起来供以后使用，检查这类参数的有效性尤为重要。例如构造器。

加入方法对于它能接受的所有参数值都能完成合理的工作，对参数的限制就应该是越来越好。

### 必要时进行保护性拷贝

假设类的客户端会尽其所能来破坏这个类的约束条件，因此你必须保护性地设计程序。

对于构造器的每个可变参数进行保护性拷贝是必要的。

保护性拷贝是在检查参数的有效性前进行的，并且有效性检查是针对拷贝后的对象。

参数的保护性拷贝并不仅仅针对不可变类。

在内部组件被返回给客户端之前，对它们进行保护性拷贝也是同样的道理。

可以肯定的说，上述的真正启示在于，只要有可能，都应使用不可变类作为对象内部的组件，这样就不用为保护性拷贝操心。

### 谨慎设计方法签名

谨慎地选择方法的名称。

不要过于追求提供便利的方法。每个方法应该权责分明。

避免过长的参数列表。可以1. 重构方法，将方法拆分为多个方法。2. 使用辅助类，将有关的信息抽象。3.对对象构建到方法调用都采用Builder模式。

对于参数类型，要优先使用接口而不是类。

对于boolean参数，要优先使用两个元素的枚举类型。

### 慎用重载

调用哪个重载方法是在编译期做出决定的。

对于重载方法的选择是静态的，对于被覆盖的方法的选择是动态的。

覆盖机制是规划，重载机制是例外。

永远不要到处两个具有相同参数数目的重载方法。

如果对于『任何一组给定的实际参数将应用于哪个重载方法上』始终非常清楚，那么，导出多个具有相同参数数目的重载方法就不可能使程序员感到混淆。

让更具体化的重载方法调用转发给更一般化的重载方法。

### 慎用可变参数

不必改造具有final数组参数的每一个方法；只当确实是在数量不定的值上执行调用时才使用可变参数。

### 返回零长度的数组或者集合，而不是null

返回类型为数组或集合的方法没理由返回null，而不是返回一个零长度的数组或者集合。

### 为所有导出的API编写文档注释

为了正确地编写API文档，必须在每个被导出的类、接口、构造器、方法和于声明之前增加一个文档注释。

方法的文档注释应该简洁地描述出它和客户端之间的约定。

除了前提条件和后置条件之外，每个方法还应该在文档中描述它的副作用。

每个文档注释的第一句话成了该注释所属元素的概要描述。

当为泛型或者方法编写文档时，确保要在文档中说明所有的类型参数。

当为枚举类型编写文档时，要确保在文档中说明常量。

为注解类型编写文档时，要确保在文档中说明所有成员，以及类型本身。

包级私有的文档应该放在package-info中。

JavaDoc具有『继承』方法注释的能力。--@inheritDoc

为了降低文档注释中出错的可能性，一个简单的方法是通过一个HTML检查器来进行检查。

## 通用程序设计

### 将局部变量的作用域最小化

要使局部变量的作用域最小化，最有力的方法就是在第一次使用它的地方声明。

几乎每个局部变量的声明都应该包含一个初始化表达式。

循环中提供了特殊的机会来将变量的作用域最小化。

如果在循环终止之后不再需要循环变量的内容，for循环优先于while循环。

使用for循环的另一个优势是更简短，从而增强了可读性。

最后一种『将局部变量的作用域最小化』的方法是使方法小而集中。

### for-each循环优先于传统的for循环

。。。

### 了解和使用类库

用轮子的好处：

1. 轮子经过广泛测试。由更专业的库制造者构建。
2. 不必浪费时间为那些与工作不太相关的问题提供特别的解决方案，应该把时间花在应用程序上，而不是底层的细节上。
3. 它们的性能往往会随着时间的推移而不断提高，无需你做努力。
4. 使自己的代码融于主流。这样的代码更易读、易于维护、被广泛重用。

### 如果需要精确的答案，请避免使用float和double

要怪就怪IEEE754。。。

Java提供了BigDecimal和BigInteger。。。


### 基本类型优先于装箱基本类型

基本类型性能更好，更加简单。

### 如果其他类型更合适，则尽量避免使用字符串

以下为Anti-Patterns:
 
1. 使用字符串代替其他的值类型
2. 使用字符串替代枚举
3. 使用字符串替代聚集类型 -- 编写类来描述这个数据集
4. 使用字符串替代能力表

### 当心字符串连接的性能

StringBuilder/StringBuffer欢迎你。

### 通过接口引用对象

如果有合适的接口类型存在，那么对于参数、返回值、变量和域，就都应该使用接口类型进行声明。

如果没有合适的接口存在，完全可以用类而不是接口来引用对象。

### 接口优先于反射机制

反射的缺陷:

1. 丧失了编译期类型检查的能力
2. 执行反射访问所需要的代码比较笨拙和冗长
3. 性能损失

如果只是以非常有限的形式使用反射，虽然也要付出少许代价，但是可以获得虚火好处。

对于有些程序，如果无法在编译期获取类对象，但是在编译期存在适当的接口或者超类，通过它们可以引用这个类。

### 谨慎地使用本地方法

使用本地方法来访问特定于平台的机制是合法的，但是随着Java平台的不断成熟，它提供了越来越多以前只有宿主平台才拥有的特性。

使用本地方法提高性能的做法不值得提倡。

使用本地方法有严重的缺点：不安全性。

### 谨慎地进行优化

优化的弊大于利。

不要因为性能而牺牲合理的结构。要努力编写好的程序而不是快的程序。

这并不意味着，在完成程序之前就可以忽略性能问题。

努力避免那些限制性能的设计决策。

要考虑API设计决策的性能后果。

API设计对于性能的影响是非常实际的。

一般而言，好的API设计也会带来好的性能。

每次试图做优化之前或者之后，要对性能进行测量。

性能剖析工具有助于你决定应该把优化的重点放在哪里。

### 遵循普遍接受的命名惯例

这个平时做Java的童鞋应该不陌生，跳过。

## 异常

### 只针对异常的情况才使用异常

异常应该只用于异常的情况下；它们永远不应该用于正常的过程流。

设计良好的API不应该强迫它的客户端为了正常的控制流而使用异常。

### 对可恢复的情况使用受检异常，对编程错误使用运行时异常

如果期望调用者能够适当地恢复，对于这种情况就应该使用受检的异常。

用运行时异常来表明编程错误。

### 避免不必要地使用受检的异常

被一个方法单独抛出的受检异常，会给程序员带来非常高的额外负担。

### 优先使用标准的异常

重用现有的异常有多个方面的好处：

1. 它使你的API更易于学习和使用，因为它和程序员已经熟悉的习惯用法是一致地。
2. 对于用到这些API的程序而言，它们的可读性会更好，因为不会出现很多程序员不熟悉的异常。


### 抛出与抽象相对应的异常

更高层的实现应该捕获底层的异常，同时抛出可以按照高层抽象进行解释的异常。

尽管异常转译与不加选择地从低层传递异常的做法相比有所改进，但是它也不能被滥用。

如果无法避免低层异常，次选方案是，让更高层来悄悄地绕开这些异常，从而将高层方法的调用者与低层的问题隔离开。

### 每个方法抛出的异常都要有文档

描述一个方法所抛出的异常，是正确使用这个方法时所需文档的重要组成部分。

始终要单独地声明受检的异常，并且利用Javadoc的@throws标记。

使用Javadoc的@throws标签记录下一个方法可能抛出的每一个未受检异常，但是不要使用throws关键字将未受检的异常包含到方法的声明里。

如果一个类的许多方法处于同样的原因抛出同一个异常，在该类的文档中对这个异常建立文档，这个可以接受的。

### 在细节消息中包含能捕获失败的信息

为了捕获失败，异常的细节消息应该包含所有『对该应该有贡献』的参数和域的值。

### 努力使失败保持原子性

一般而言，失败的方法调用应该使对象保持在被调用之前的状态。-- 失败原子性

最简单的莫过于设计一个不可变的对象。

最常见的是，在执行操作之前检查参数的有效性。

或者可以调整计算过程的顺序，使任何可能失败的计算部分都在这个对象状态被修改之前发生。

或者写一段恢复代码，由它来拦截过程操作中发生的失败。

最后一种是，对对象进行CopyAndSwap。

### 不要忽略异常

一个空的catch块会使异常达不到应有的目的。

## 并发

### 同步访问共享的可变数据

如果没有同步，一个线程的变化就不能被其他线程看到。

JLS保证读或者写一个变量是原子的。

你可能听说过，为了提高性能，在读或者写原子数据时，应该避免使用同步。这个建议是非常危险和错误的。

为了线程之间进行可靠的通信，也为了互斥访问，同步是必要的。

如果读和写操作没有被同步，同步就不会起作用。

将可变数据尽量限制在单个线程中。

当多个线程共享可变数据的时候，每一个读或者写数据的线程都必须执行同步。

### 避免过度同步

过度使用同步会导致死锁或者数据破坏。

为了避免活性失败或者安全性失败，在一个被同步的方法或者代码块中，永远不要放弃对客户端的控制。

要将外来方法的调用移出同步的代码块，还有一种更好的方法。即保护性复制

通常，你应该在同步区域做尽可能少的工作。

同时，加锁会带来性能问题。

如果你在内部同步了类，就可以通过使用不同的方法来实现高并发性，比如分拆锁、分离锁和非阻塞并发控制。

### executor和task优先于线程

你不仅应该尽量不要编写自己的工作队列，而且还应该尽量不直接使用线程。现在关键的抽象不再是Thread了，它以前可是既充当工作单元，又是执行机制。

### 并发工具优先于wait和notify

既然正确的使用wait和notify比较困难，就应该用更高级的并发工具来替代。

并发集合中不可能排除并发活动；将它锁定没什么作用。

这部分内容，我更推荐阅读《Java并发编程实践》。来深度阅读

### 线程安全性的文档化

当一个类的实例或者静态方法被并发使用的时候，这个类的行为如何，是该类与其客户端程序建立的约定的重要组成部分。

在一个方法声明中出现synchronized修饰符，这个是实现细节，并不是导出的API的一部分。

一个类为了可被多个线程安全地使用，必须在文档中清楚的说明它所支持的线程安全级别：

- 不可变的
- 无条件的线程安全
- 有条件的线程安全
- 非线程安全
- 线程对立的

你必须指明哪个调用序列需要外部同步，还要指明为了执行这些序列，必须获得哪一把锁。

类的线程安全说明通常放在它的文档注释中，但是带有特殊线程安全属性的方法则应该在它们自己的文档注释中说明它们的属性。

私有锁对象模式只能用在无条件的线程安全类上。

私有锁对象模式特别适用于那些专门为继承设计的类。

### 慎用延迟初始化

对于延迟初始化，最好建议『除非绝对必要，否则就不要这么做』。

在绝大多数情况下，正常的初始化要优先于延迟初始化。

如果利用延迟优化来破坏初始化的循环，就要使用同步访问方法。

如果处于性能的考虑而需要对静态域使用延迟初始化，就使用lazy initialization holder class model。

如果处于性能的考虑而需要对实例域使用延迟初始化，就要使用双重检查模式。我在单例模式的文章中讲过这个，有兴趣请移步第一篇文章。

### 不要依赖于线程调度器

任何依赖于线程调度器来达到正确性或者性能要求的程序，很有可能都是不可移植的。

要编写健壮的、响应良好的、可移植的多线程应用程序，最好的办法是确保可运行的程序平均数量不明显多于处理器的数量。

如果线程没有在做有意义的工作，就不应该运行。

线程不应该移植处于忙-等的状态。

线程优先级是Java平台最不可移植的特征了。

### 避免使用线程组

因为线程组已经过时了，所以实际上根本没有修正。。。

Not Use It At All。。。


## 序列化

### 谨慎地实现Serializable接口

实现Serializable接口而付出的最大代价是，一旦一个类被发布，就大大降低了『改变这个类的实现』的灵活性。

如果你接受了默认的序列化形式，并且以后又要改变这个类的内部表示法，结果可能导致序列化形式的不兼容。

序列化会使类的演变受到限制，这种限制的一个例子和序列版本UID有关。

实现Serializable的第二个代价是，它增加了出现bug和安全漏洞的可能性。

实现Serializable的第三个代价是，随着类发行新的版本，相关的测试负担也增加了。

为了继承而设计的类应该尽量少地实现Serializable接口，用户的接口也应该尽可能少地继承Serializable接口。

对于为继承而设计的不可序列化的类，你应该考虑提供一个无参构造器。

最好所有的约束关系都已经建立的情况下再建立对象。

内部类不应该实现Serializable。

### 考虑使用自定义的序列化形式

如果没有先认真考虑默认的序列化形式是否合适，则不要贸然接受。

如果一个对象的物理表示法等同于它的逻辑内容，可能就适合于使用默认的序列化方式。

即时你确定了默认的序列化形式是合适的，通常还必须提供一个readObject方法以保证约束关系和安全性。

当一个对象的物理表示法与它的逻辑数据内容有实质性的区别时，使用默认序列化形式会有以下四个缺点：

- 它使这个类的导出API永远地束缚在这个类的内部表示法。
- 它会消耗过多的空间。
- 它会消耗过多的时间。
- 它会引起栈溢出。

不管你选择了哪种序列化形式，都要为自己编写的每一个可序列化的类声明一个显式的序列版本UID。


### 保护性地编写readObject方法

每当你编写readObject方法的时候，都要这样想：你正在编写一个公有的构造器，无论给你传递什么样的字节流，它都必须产生一个有效的实例。不要假设这个字节流一定代表着一个真正被序列化过的实例。

- 对于对象引用域必须保持为私有的类，要保护性地拷贝这个域中的每个对象。
- 对于任何约束条件，如果检查失败，则抛出一个InvalidObjectException异常。这些检查动作应该跟在所有的保护性拷贝之后。
- 如果整个对象图在被反序列化后必须进行验证，就应该使用ObjectInputValidation接口。
- 无论是直接方式还是间接方式，都不要调用类中任何可被覆盖的方法。

### 对于实例控制，枚举类型优先于readResolve

readResolve的可访问性很重要。

你应该尽可能地使用枚举类型来实施实例控制的约束条件。如果做不到，同时又需要一个既可序列化又是实例受控的类，就应该提供一个readResolver方法，并确保类的所有实例都为基本类型，或者是transient的。

### 考虑用序列化代理替代序列化实例

每当你发现自己必须在一个不能被客户端扩展的类上编写readObject或者writeObject方法的时候，就应该考虑使用序列化代理模式。要想稳健地将带有重要约束条件的对象序列化时，这种模式可能是最容易的方法。