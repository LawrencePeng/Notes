title: 《More Effective C++》读书笔记
tag: [C++, Effective, 读书, 笔记]
category: 读书
------

新年还木有过，给大家补声新年快乐哈，红包拿来hhh，因为回到了无网络状态的老家一段时间，所以一直没有更新。现在补回来啦hhh。Lisp实现版本将会再后续的时间内补写，当然还有位运算系列。。。这坑真多。

# 简介

书名为《More Effective C++》。当然就是《Effective C++》的拓展啦。之前写过《Effective C++》的笔记，有兴趣的可以再逛逛。这本书相对较薄，但是干货还是满满的。总共35条条款，还是很有用哒。推荐想要更进一步了解C++的开发者阅读。


# 笔记

## 基础议题

### 区分指针和引用

引用必须要指代某个非空对象。

使用引用比使用指针高效，因为无需进行检查。

### 优先考虑C++风格的类型转换

在《Effective C++》中已经进行了讲解。

这里给出书中对于不支持C++风格的类型转换的情况的妥协办法。这里的static_cast可以类比到其他的转型。

```#define static_cast(T,E) ((T),(E))```

### 决不要把多态应用于数组

实际上，当你进行数组声明的时候，编译器也通过声明来确定指针位移差。

所以，编译器并不会智能地移动到应该移动的位置。

记住标题，永不犯错。

### 避免不必要的默认构造函数

这点大家都很清楚，不过在执行的时候就没有那么容易了。

通常，有删个理由造成了你不能轻易地遵行这一条约。

1. 如果一个类没有默认构造函数，使用这个类的时候就会有很多限制。

比如数组初始化的时候，没有默认构造函数会导致不能初始化。

2. 第二个问题是它们无法作为许多基于模板的容器内的类型参数使用。

3. 在有虚基类的时候没有默认构造函数使用起来会很痛苦。

但是提供无意义的默认构造函数也会影响类的执行效率。


## 运算符

### 小心用户自定义的转换函数

最根本的问题是，这些函数经常会在你根本不希望进行类型转换的时候被调用。

一般而言越有经验的C++程序员就越倾向于避开类型转换运算符。

可以用explicit关键字来避免隐式类型转换的问题。

也可以通过代理类的方式来避免类型转化。


### 区分自增运算符和自减运算符的前缀形式和后缀形式

这点属于C++运算符中的知识点，这里就不展开了。不过记住一个Note ++something is better than something++；


### 不要重载『&&』、『||』、『,』

很难想象有人会引火烧身。

### 理解new和delete在不同情形下的含义

new操作究竟干了什么。笼统地说可以是1. 开辟一份内存。2.调用构造器 3.进行类型转换

同样delete也可以理解为1.调用析构器 2. 释放内存资源

然后后面讲解了new和delete的定制。这里我不是很感冒，pass掉。


## 异常

### 使用析构函数防止内存泄露

本节内容在《Effective C++》中有对应讲解。就不做赘述了。

### 防止构造函数里的资源泄露

C++拒绝为构造未完全的对象进行析构，所以这要求你的设计必须要考虑异常处理。

如果把那些声明为指针的类成员替换成相应的指针指针对象，在发生异常的时候构造函数就可以避免资源泄露，并且免去了在析构函数中手工释放资源的必要，此外，还可以像处理非常量指针那样以得体的方式来处理常量成员指针。

### 阻止异常传递到析构函数以外

允许异常传递到析构函数外面是个不好的习惯，因为首先，在异常传递进行到堆栈解开部分的时候，它可以阻止terminate函数被调用。其次，它确保了析构函数总是做完它们应该完成的事情。

### 理解抛出异常和传递参数或者调用虚函数之间的不同

C++要求对象必须以拷贝的形式抛出异常。

当一个对象作为异常被拷贝的时候，这个拷贝是由该对象的拷贝构造函数来实施的。

一个由异常抛出的对象可以由一个简单的引用捕获，而不必非得由指向常量对象的引用来捕获。

第二个不同是函数调用者和被调用函数之间、异常抛出者和捕获者之间都存在类型匹配，而它们所遵循的类型匹配规则是不同的。函数调用中类型匹配是允许隐式转换的，而异常抛出则不会。


虚函数的调用遵循最优匹配，而异常则不是。

### 通过引用捕获异常

使用指针来传递异常意味着你可能会指向一个已经不存在的对象。或者如果对象来自堆，你就必须要考虑它的删除。

通过值进行传递异常则会导致2次拷贝，带来性能损耗。同时会有对象切割问题。

使用引用捕获异常。通过引用捕获异常没有上面我们讨论过的这些问题。

### 审慎地使用异常规格

异常规格使得代码更加容易理解，因为它们明确指出了一个函数可能抛出的异常。

但是，大多数时候，unexpected函数在默认情况下会调用terminate函数，而大多数函数会调用about函数。

Note：不要把模板和异常规格混合使用。

文中后面讲解了一些方法来避免使用异常规格时遇到unexpected error的问题时的解决方法。

包括： 1. 如果某个函数所调用的其他函数没有异常规格，那这个调用函数也要去掉异常规格。 2.处理『系统』本身可能抛出的异常。 3. 把unexpected 异常翻译成已知类型的异常的方法是替换unexpected函数，重新抛出异常，其类型转换为bad_exception。

### 理解异常处理所付出的代价

你会为异常付出一些代价。包括性能损失，不过实际应用中这不是一个大问题。


## 效率

个人觉得是本书最优秀的两部分之一。


### 记住80-20准则

一方面，80-20准则意味着大多数时候你可以写一些性能相当一般的代码，因为80%的时间的运行效率并不影响程序的整体性能。另一方面，这条准则意味着如果你的程序出现了运行效率上的问题，那接下来就是相当棘手的工作。

大部分人定位性能瓶颈的时候是通过猜测。

大多数程序员对于程序的性能特征都有自己的直觉，而这些直觉通常是不怎样样的，因为程序的性能特征一般是不怎么符合直觉的。

一种情况下，如果面临运行速度很慢或者非常消耗内存的情况，可行的办法是根据实验确定出导致性能瓶颈的啦80%的程序。例如通过分析器。

即时最好的分析器其分析结果也要取决于它说处理的数据。

要防止这种不正常的结果，最好的办法是用可能多的数据来分析你的软件。

### 考虑使用延迟计算

#### 引用计数

类似于shared_ptr的实现。很常见，不见

#### 区分读操作和写操作

后面会见到使用多种方法实现读写操作的区分

#### 延迟读取

实现Lazy Fetching时，你面临的一个问题是，在任何成员函数里都有可能需要初始化空指针使其指向真实的数据。

#### 延迟表达式求值

即只保留表达式，而非即时求值。

可以避免不必要的计算。

### 分期摊还预期的计算开销

提前计算背后的实现时，如果你预计某个运算会被频繁调用，你可以通过设计你的数据结构以更高效的方式来处理这些请求，这样来降低每次请求的平均开销。

最简单的一种做法是缓存已经被计算过的那些值。

预读取则是另一种方法。这部分的例子有很多，比如cpu的pipeling的思想等。

贯穿本条款是一个常见的主题，可以通过消耗更多的内存来获得更快的速度。

然而情况不总是这样。例如大的对象并不适合虚拟内存和缓存页。

### 了解临时对象的来源

这一部分很多内容已经被C++的move语义解决了。

1. 以传值方式传递对象时产生的拷贝成本。而C++禁止非常量引用产生临时对象。
2. 函数返回对象时会产生临时对象。可以被move语义改善。

### 协助编译器实现返回值优化

C++程序员应该不会对返回值优化感到陌生。实际上，现代的编译器都对返回值有很好的优化。

很多人，包括以前我，经常傻傻地为了减少返回值复制成本，会选择在堆上新建对象来返回，然而这样自然很容易产生资源泄露。实际上，如果你小改一下代码，使得它能被编译器识别为可返回值优化的类型。那么同样也可以避免这个问题。在C++11中，move语义的引入让我们从语义上解决这个问题，而不是编译期由编译器实现。

### 通过函数重载避免隐式类型转换

隐式类型转换或许会很方便，但是也带来了性能上的开销。一种可行的方式来消除它是定义函数重载，来避免这些多余的构造函数成本。

不过我其实不是很推荐这种做法，如果不是对性能有过分严苛的要求，完全不应该进行这种优化。

### 考虑使用op =来替代单独的op运算符

使用operator= 重载来实现其他的op运算符重载。

赋值形式的运算符要比单独形式的运算符高效些。赋值形式的运算符直接写回给运算符左边的参数，所以不需要提供一个保存运算符返回值的临时对象。

提供赋值版本的运算符以及单独形式的运算符，可以让使用的类的客户在效率和方便性之间做出选择。

### 考虑使用其他等价的函数库

库的选择使用和发现相信程序员都不会困难，毕竟我们是非常善于使用工具的人。

根据不同的情形，权衡不同的库，是我们工作中的一部分。

### 理解虚函数、多重继承、虚基类以及RTTI所带来的开销

这点在《C++对象实现机制》中有大篇幅的描写，推荐进行进一步的阅读。

简而言之，C++的虚函数是依赖虚函数表来实现的。虚函数表的实现不同的编译器是不一样的。

在实际应用中虚函数不应该内联。

多重继承经常基类会被定制为虚基类。虚基类也会带来一些开销，因为虚基类的实现经常使用指向虚基类的指针作为避免重复的手段，这样就需要在对象内部嵌入一个或者多个指针。

RTTI的一种实现方式是在类vtbl中加入一个type_info对象。使用这种办法就会在每个类中添置一些空间占用。

总结

虚函数会增加对象的大小，会增加每个相关类的数据量，同时会消除内联的作用。

多重继承会增加对象大小，会增加每个相关类的数据量。

虚基类多会增加对象大小，有时会增加每个类的数据量。

RTTI不会增加对象大小，但是会增加每个类的信息量。


## 技巧

此部分精彩斐然。我建议你购置或借阅此书。哪怕只为了这一部分的内容也好。这一部分深入探讨了几个方面的内容。条款25关注如何让构造函数和普通函数具有虚函数的行为。条款26关注如何限制类对象的个数。我之前写过关于单例模式的讨论，在此书中也有提及。条款27展示了如何让对象值分配到堆或栈中。简要的说就是将对象的析构函数隐藏以达到之能分配到堆的效果。而只需将new运算符和delete运算符声明为私有就可以使对象只分配到栈中。条款28关注智能指针设计时的考虑的细节。条款29则关注如何实现引用计数功能，实际上shared_ptr也是如此。条款30让我们了解了代理类的使用实际和要点。并演示了一些区分读操作和写操作的实现。条款31则聚焦于基于多个对象的虚函数的实现。这里我不详细阐述。如果你真的感兴趣，请自行阅读。


## 杂项

### 在将来时态下开发程序

如果你愿意承认事物是会变化的。那么你更可能为了应对将来的变化而设计。禁止掉不应该有的。想好能做什么，不能做什么。这能强迫你思考更多你本应该思考的细节。

### 将非尾端类设计为抽象类

这是一种非常常见的设计方式。即时你可能只有几个小类，但是未来是无法预测的。将它们公共的部分抽象成父类，让这些思想继承它们，是一种常见的设计方式。

### 理解如何在同一程序中使用C++和C

简而言之。

1. 确保C++和C编译器能产生兼容的obj文件
2. 将在两个语言下都使用的函数声明为extern "C"
3. 只要可能，尽量用C++写main函数
4. 总是使用delete来释放new分配的内存；总是使用free来释放malloc分配的内存
5. 将在两种语言之间进行传递的东西限制在可以用C进行编译的数据结构访问类；C++版本的struct可以包括非虚成员函数

 