title: 《编程珠玑》读书笔记
category: 读书
tag: [编程, 读书, 笔记, 编程珠玑]

------

# what is 编程珠玑

《编程珠玑》是一本编程经典书籍。《编程珠玑》获得了诸多好评，其中最大牌的应该就是《代码大全》的作者的评价了 -- 『《编程珠玑》是对我职业生涯早期影响最大的书之一，其中的许多真知灼见多年之后仍然使我受益匪浅。』书中选取了一些与编程相关的小片段进行讲解，其中，关于数据结构与算法的讨论占据了非常大的篇幅。
书中分3部分:

1. 基础
2. 性能
3. 应用


# 笔记

## 基础

### 开篇

第一章围绕这么一个问题展开。一个文件中有1千万条记录，每个记录都是7位数字的整数。然而只有1MB左右的内存可用。这意味着，如果你想要使用我们在数据结构中学到的排序方式，你就不得不多次读写大约40次文件来完成。还有什么办法么？

答案是我们使用BitMap，开出10，000，000个储存空间，这大约需要1.25MB的内存，符合题目要求。然后将检查文件记录，有记录的就把内存相应坐标位的储存空间置1，最后按序扫描内存中的存储空间写入。

这是ACM中常用的一种技巧。。。

其实计数排序中也有用到这个思想。

如果我们的内存撑死只有1MB怎么办呢？ 我们可以进行两趟排序，将前一半范围的数据输入进1个文件，后一半输入到另一个文件，在分别写入到目标文件。这个一种在时间-空间商的折中与双赢的策略。

我们通过这个例子得出，我们能得到什么呢？

1. 正确的理解问题。
2. 一种叫做BitMap的数据结构。
3. 多趟算法。
4. 时间-空间上的权衡

### 啊哈！算法

这一章围绕3个问题进行讨论。

A. 给定一个最多包含40亿个随机排列的32位整数的顺序文件，找出一个不在文件中的32位整数。 -- 二分查找

B. 将一个n元一维向量向左旋转i个位置。 -- 一道经典的编程练手题，后面做出讲解。

C. 变位词问题 -- 也是一个很经典的题目了。-- 词内字典顺序排序后词间排序是常用的招数。

关于Problem B: 一个让人惊叹不已的方法是利用矩阵求逆的性质，即ab求逆 = 对a求逆，再对b求逆，在整体求逆。

```
reverse(0, i-1); // cbadefgh
reverse(i, n-1); // cbahgfed
reverse(0, n-1); // defghabc
```

我们能学到什么呢？

1. 二分查找。
2. 寻找等价关系。
3. 问题定义 -- 再一次强调正确的理解问题。

### 数据决定程序结构

本章关心数据的作用，由于年代久远，其举得例子都太过于成就或者按照今天的眼光看，不值一提了。

例如3.2中格式信函编程完全就是简略版的HTML模板。。。

不过本章的意图很值得学习: 数据决定数据结构。一个优秀的程序应该是依据数据性质使用了合适数据结构的。一个优秀的程序员在思考项目时，编写代码时，脑中应该映射的数据和数据结构的关系。

同时应该学会使用一些工具，简化事情的复杂度，关心应该关心的。例如一些常用的中间件:数据库、CDN...

本章我们能学到:

1. 使用数组重新编写重复代码。
2. 封装复杂结构。
3. 尽可能使用高级工具。
4. 从数据得出程序的结构。

### 编写正确的程序

写出程序或许很简单，然而，想要写出正确的事情却完全是另一回事。

如果验证你的程序是对的呢？

一个方法是形式化证明，这在CS中也是一研究领域。

本章以二分查找作为例子，运用循环不定式来验证程序的正确性。

其实《算法导论》中也大量使用了这一方法。

如果对这部分内容感兴趣，可以去看《The Science of Programming》

本章我们能学到:

1. 使用断言。
2. 学会使用形式化验证的方式来验证程序正确性。


### 编程小事

这一章关注编程程序中的『脚手架』。

其中介绍了:

1. 伪代码 -- 编写程序前写伪代码。
2. 自动测试
3. 断言
4. 计时工具

这些都是现在工具链中不可少的东西了。例如计时工具,可以用语言自身提供的一些接口实现，也可以通过Unix下的time命令。

## 性能

### 程序性能分析

我们一般对代码做优化的时候可能就只会注意到代码本身的性能优化和JVM这种东西进行优化。然而本章作者举出的例子中可不只有这些:

1. 算法与数据结构
2. 代码调优
3. 硬件

在设计中:

1. 问题定义
2. 系统结构
3. 算法和数据结构
4. 代码调优
5. 系统软件
6. 硬件

都应该被重视。


### 粗略估计

本章主要关注对于估计在程序性能判断上的作用。

基本上，一个估计通常需要一下条件：

1. 将问题简化为一个可计算的模型
2. 拥有一定常识

同时也有一些小Trick:

1. 从多个角度思考问题
2. 快速检验
3. 经验法则: 『72法则』（和自然对数有关）、如果问题规模太大，使用小规模测试画曲线判断复杂度、Little定律


### 算法设计技术

本章以最大数组子区间合为例子。介绍了暴力破解、动态规划、分治法、扫描法。时间复杂度一步步从O（n^3）往下走，直到为精确下界O（n）。此题为经典题，就不赘述了。希望读者自行了解。


本章我们能学到:

1. 保持状态，避免重复计算 -- 非常常见的代码优化方式
2. 将信息预处理至数据结构中
3. 分治法
4. 扫描法
5. 累加数组 -- 动态规划
6. 确定下界 -- 实际上《算法导论》也在多处提及这方面的内容，例如用决策树模型确定比较排序的理想下界为O（nlogn）

### 代码调优

本章关心代码调优问题。如果要进行代码调优，就一定要找到代码的瓶颈。最好使用一些性能分析工具，这部分前端的同学应该还是很开心的。不过代码调优的最重要的一条是**尽量不要调优**。过早优化是一切罪恶的根源。

原因:

1. 为了效率可能损害其他也很重要的东西。比如:代码可读性，扩展性，兼容性等等。
2. 效率问题可以有多种方法解决
3. 代码优化是一把双刃剑，优化后可能会导致连锁反应。

### 节省空间

考虑下，如果有一个稀疏矩阵，它的大小是200*200，那么，它可能会占用160KB的空间。

优化1：

用类似于链地址法的方法，用数组表示列编号，非空元素用链表存在对应列编号下。

有200个指针和2000条记录的话， 占用空间是24.8KB， 明显比直接用二维数组存储要小很多。

优化2：

受启发于基数排序，我们可以开三个数组来保存这些数，如下图所示：

![](http://www.hawstein.com/assets/img/2013/8/11/3array.png)

firstincol每列存储该列的row的编号，row存储对应有效数据的行值，pointnum储存值。

这样的方案占用空间为2000x4B + 2000x1B + 201x2B = 10402B = 10.4KB。

减少空间需求的一些方法：

1. 不存储，重新计算
2. 使用稀疏数据结构，上面提及了。
3. 数据压缩
4. 分配策略 -- 例如流的使用
5. 垃圾回收

节省代码空间（压缩代码量）：

1. 函数定义 -- 使用函数增加复用性
2. 解释程序 -- 用解释程序命令替换长的程序文本。
3. 翻译成机器语言

使用现代的性能检测工具，也能对空间『瓶颈』进行探测。

学会在时空中做权衡。

同时，程序员应该对你的代码执行底层有了解，这些是Dependence。

## 应用

### 排序

本章先介绍了插入排序，然后介绍快排和其优化。

这里快排我用Python写了一个版本:

```
def Partition(arr, p, r):
    x = arr[r]
    i = p - 1
    for j in range(p, r):
        if arr[j] <= x:
            i += 1
            arr[j], arr[i] = arr[i], arr[j]
    arr[i + 1], arr[r] = arr[r], arr[i + 1]
    return i + 1
def QuickSort(arr, p, r):
    if p < r:
        q = Partition(arr, p, r)
        QuickSort(arr, p, q - 1)
        QuickSort(arr, q + 1, r)
```

这种排本比较好理解，但是缺点也比较明显。如果是一个有序，或者数组中元素相同，快排的时间复杂度就会退化成O（n^2)。

一个优化方案是:

```
partition(arr, low, high):
    pivot, i, j = arr[low], low, high
    while(i < j):
        while(i<j and arr[j] > pivot)
            j -= 1
        if(i < j):
            arr[i], arr[j] = arr[j], arr[i]
        while(i<j && a[i] <= pivot):
            i += 1
        if(i < j):
            arr[i], arr[j] = arr[j], arr[i]
    return i
    
quicksort(arr, first, last)
    if(first<last)
        int k = partition(arr, first, last);
        quicksort(arr, first, k-1);
        quicksort(arr, k+1, last);
```

这样就避免了最后还要交换一次pivot的操作。

实际上，我们可以在数组区间比较小时，调用更适合的插入排序。其实c标准库就是这么干的。

### 取样问题

问题：对于整数m和n，其中m<n，输出0~n-1范围内m个随机整数的有序列表， 不允许重复。

对于这个问题，本章给出了三种实现。

1. 来自Knuth的TAOCP， 时间复杂度O(n)：

```
void GenKnuth(int m, int n) {
    for(int i=0; i<n; ++i) {
        if((bigrand()%(n-i)) < m) {
            cout<<i<<endl;
            --m;
        }
    }
}
```

2. 在一个初始为空的集合里面插入随机整数，直到个数足够。

```
void GenSets(int m, int n) {
    set<int> s;
    while(s.size() < m)
        s.insert(bigrand() % n);
    set<int>::iterator i;
    for(i=s.begin(); i!=s.end(); ++i)
        cout<<*i<<endl;
}
```

3. 把包含整数0～n-1的数组顺序打乱，然后把前m个元素排序输出。 该方法的性能通常不如Knuth的算法。

```
void GenShuf(int m, int n) {
    int x[n];
    for(int i=0; i<n; ++i)
        x[i] = i;
    for(int i=0; i<m; ++i) {
        int j = randint(i, n-1);
        swap(x[i], x[j]);
    }
    sort(x, x+m);
    for(int i=0; i<m; ++i)
        cout<<x[i]<<endl;
}
```
我们能学到什么：

1. 正确理解问题
2. 提炼出抽象问题
3. 考虑尽可能多的解法
4. 实现一种解决方案

### 搜索

问题：在没有其他相关数据的情况下，如何存储一组整数？

其实有多种方案，书中提及了5种:

1. 有序数组
2. 有序链表
3. 二叉搜索树
4. 箱 -- 桶排序中的桶
5. BitMap

我们能学到什么:

1. 库的作用
2. 空间的重要性
3. 代码调优方法

### 堆

这章主要讲解堆的作用。由于这一章的内容在《算法导论》中有很好的描述，所以不细讲。

我们能学到什么：

1. 选用高效的数据结构。

2. 过程抽象和数据抽象来构造抽象屏障 -- 《SICP》前两章对此有精彩的讲解。

### 字符串

现在我们需要一个单词去重功能。这当然很容易实现。

```
int main(void) {
    set<string> s;
    set<string>::iterator j;
    string t;
    while(cin >> t)
        s.insert(t);
    for(j=s.begin(); j!=s.end(); ++j)
        cout<<*j<<endl;
    return 0;
}
```

现在我们要统计单词的词频。这也很容易实现。

```
int main(void) {
    map<string, int> m;
    map<string, int>::iterator j;
    string t;
    while(cin >> t)
        m[t]++;
    for(j=m.begin(); j!=m.end(); ++j)
        cout<<j->first<<" "<<j->second<<endl;
    return 0;
}
```

这个程序已经能非常快了。如果你还想更快，那就在数据结构上下功夫吧。

我们使用哈希表来实现。这样，我们的插入和读取都能在O(1)下完成。

```
class Hash {
public:
    Hash(): seed_(131), size_(0) {
        memset(head_, 0, sizeof(head_));
    }
    
    void Insert(const char* str) {
        unsigned int id = hash(str);
        char *dst = (char*)node_[size_].word;
        while(*dst++ = *str++);
        node_[size_].next = head_[id];
        head_[id] = &node_[size_];
        ++size_;
    }

    bool Find(const char* str) {
        unsigned int id = hash(str);
        for(Node* p=head_[id]; p; p=p->next) {
            char* dst = (char*)p->word;
            int i = 0;
            for(; *(str+i) && *(str+i)==*(dst+i); ++i);
            if(!*(str+i) && !*(dst+i)) return true;
        }
        return false;
    }
    
private:
    unsigned int hash(const char* str) {// BKDR Hash Function
        unsigned int hash = 0;
        while(*str) {
            hash = hash * seed_ + (*str++);
        }
        return (hash & 0x7FFFFFFF) % kHashSize;
    }
    
private:
    unsigned int seed_;
    unsigned int size_;
    static const int kWordSize = 26 + 1;
    static const int kNodeSize = 20000;
    static const int kHashSize = 10001;
    struct Node {
        char word[kWordSize];
        Node *next;
    };
    Node node_[kNodeSize];
    Node* head_[kHashSize];
};
```

换成哈希后，缺陷是不提供最最坏情况保证。不过在大部分常见的情况下，是很难遇到的。不过，它不支持顺序操作，这个就没办法了。

现在我们有这么一道题: 给定一个文本文件做输入，查找其中最长的重复子字符串。

这里介绍一个强大的字符串处理工具 -- 后缀数组。

如果一个字符串为"abcba"。那么其后缀数组为:
{"a","ba", "cda", "bcba", "abcba"}。

我们排序下。

{"a","abcba","ba","bcba","cda"}

可以看到。
最长后缀就是"a"。

所以，构建后续数组，查找一次数组，比较相邻字串的最长公共前缀即可。

# 后记

《编程珠玑》的文笔幽默，也不乏趣事，整本书读起来不会感觉到累。《编程珠玑》的题目也多很有趣而且需要动动脑筋才能解决。本书短小精悍，绝大部分的内容都是精华。推荐阅读。
