title: 《C陷阱与缺陷》读书笔记
category: 读书
tag: [C/C++, 读书, 笔记]

------

《C陷阱与缺陷》是C/C++四书五经中的一本。也是毫无疑问的一本C语言经典书籍。

这本书讲解了C语言的一些奇怪的语法，容易出错的地方，和一些C可以设计的更好的部分。

这本书的写作目的并不是为了吐槽C语言，实际上，在我看来，书中第1-3章关于「C陷阱」的内容很大程度上普遍发生在初学编程者中。只要对于C有一定认识的读者，都不太可能会写出缺陷部分的那种文章。同时，第4-5章的缺陷部分内容中有很多根本就不应该被当做缺陷，有一些因为语言或者工具链本身的发展，使用或出错的可能性已经几乎为0了。如果去除这些我认为很受争议的部分，基本就不剩下什么内容了。不过也要考虑到作者写这本书的年代，在那种C语言本身都还不完善、工具链远不如今天的情况下，这些内容或许仍然还是有很多洞见的。我给出本书已经不适合阅读的评价。

也希望读者在看这篇读书笔记的时候，能够有去根据现在的情景看问题。


# 词法『陷阱』

1. = 不同于 ==

	= 用于赋值
	
	== 用于判断数值是否相等
	
	私货: 其实=为赋值的设计是反直觉的，于是我看到有些工具(比如R)就选择用其他标记来替代类C的赋值判断符。有一种Yoda表示法(来自《星球大战》系列的师父的讲话方式)就是用来尽量避免这种反直觉导致的程序员的出错。比如使用if(nullptr == x)而不是if(x == nullptr)，因为担心程序员粗心少打了一个空格。。。不过现在大量工具都能检查出这种错误，并不知道还有什么价值，不过作为编程好习惯，在像C这种的语言，遵守也不赖。
		
2. & 和 | 不同于 && 和 ||  ------ 直接过

3. 词法分析中的贪心法 
	
	可以使用贪心法来识别表达式语法结构。比如a---b 等于 a-- - b。不过现实中应该尽量避免写出这种代码。
	
4. 整形常量 -- 数字前加0为八进制数。

5. 支付和字符串 -- ' 和 " 别误用

# 词法陷阱

1. 理解函数指针

	对于函数指针不了解的可以去看其他资料复习下。这里讲两点:
	
	1. 函数指针的使用在C中有很好的支持，可以让C来实现一部分FP的思想。
	
	2. 应该使用typedef来增加这种类型定义的可读性

2. 运算符的优先级问题 -- 熟悉运算符优先级，一种简单的记法是单目 > 双目 > 三目 位运算大于逻辑运算。

3. 注意作为语句结束标志的分号 -- 记得写";"。。。

4. switch语句: C语言讲case标号视为简单的标号而已，所以记得break;

5. 函数调用 -- 记得写()。。。

6. 『悬挂』else引发的问题

	这里还是啰嗦几句。我们容易犯所见即所得的毛病。所以下面的代码你可能会以为else对应的是第一个if的。
	
		if(x == 0)
			if (y == 0) error();
		else {
			z = x + y;
			f(&z);
		}
	
	这里还是有很多语言做了不一样的选择的。有一些语言(比如Go）就强制你不可以忽略{}，另一些则选择用缩进来表示Block结构。平时养成好的编程习惯，你其实不需要这些约束的。
	
# 语义『陷阱』

1. 指针与数组 --- 老生常谈了。对C有一定了解的都不会弄错。

2. 非数组的指针

	1. malloc可能分配空间失败，记得判断返回值。
	
	2. char r[100]实际上会分配101个空间 -- 居然要讲这种东西。。。
	
	3. 记得free。。。

3. 作为参数的数组声明 -- 传参数时数组转型为指针。。。

4. 避免『举隅法』 -- 复制数组、字符串不能直接对指针赋值。。。

5. 空指针并非空字符串 -- 就这样

6. 边界计算与不对称边界 -- 1--10有几个数，0--10有几个数

7. 求值顺序 -- 还是运算符优先级问题

8. 运算符&&、||和! -- 这些运算符不深刻理解的都好好面壁去。。。

9. 整数移除
	提供了两种判断整数溢出的方法
	
	1. 转换为unsigned 判断是否大于有符号的最大值。

	2. 如果 a + b > SIGNED_MAX_VAL 则 a > SIGNED_MAX_VAL - b

	我平时也是使用第一种居多，Google Guava源代码Math包中也是大量使用了第一种方法。
	
10. 为main函数提供返回值 -- 没什么好说的。

# 连接 -- 本书唯一还可能有点意义的部分

1. 什么是连接器(链接器)
	
	C语言中一个重要思想就是分别编译，将若干个源程序在不同时候单独进行编译，然后在适当的时候整合到一起。
	
	典型的连接器把由编译器生成的若干个目标模块，整合为可执行文件。
	
	连接器通常把目标模块看成是由一组外部对象组成的。每个对象代表着机器内存的某一部分，并通过一个外部名称来识别。
	
	连接器需要解决命名冲突问题，对于静态函数或者变量，不存在命名冲突问题。
	
	对于发生的命名冲突问题，绝大多数的连接器都会直接禁止。
	
	除了外部对象之外，目标模块中可能还包括了对其他模块中的外部对象的引用。
	
2. 声明与定义

	在文件全局范围声明变量则该变量为外部对象。
	
	使用extern能向连接器说明该对象为对外部对象的引用而非定义。
	
3. 命名冲突与static修饰符
	
	两个或两个以上的同名外部对象会导致命名冲突。
	
	static 修饰符能使变量、函数作用域限制于一个源文件内。
	
4. 形参、实参与返回值 -- 如果一个函数在被定义或声明之前被调用，那么它的返回类型就是默认整形。。。
	
5. 检查外部类型 -- 声明与定义的统一同样适用于外部变量(废话)

6. 头文件 -- 每个外部变量只在一个头文件中声明，定义该外部对象的模块都应该包括这个头文件。

# 库函数

1. 返回整数的getchar() -- 不语。。。

2. 更新顺序文件 -- 输入不能在输出前，如果要应该插入fseek()

3. 缓冲输入与内存分配-- setbuf()使用的缓冲应该为静态或者动态分配

4. 使用errno检查错误 -- 应该检查函数的返回值，再检查errno，而不是直接检查errno

5. 库函数signal -- 信号非常复杂棘手，并且本质上不可移植。所以应该让处理函数尽可能简单，并将它们组织在一起。

# 预处理器(宏)

1. 不能忽视宏定义中的空格 --老生常谈

2. 宏并不是函数

	宏只是编译器的替换而已，里面坑多多。
	
	一种避免宏展开后出错的方法是调用和定义时尽量减少副作用。
	
	其实现代的编译器基本都能够自动识别或者手动指明函数进行内联。所以其实意义不大了。不过在一些场景还是有些作用的。
	
3. 宏并不是语句

	。。。遇到一堆宏乱飞的代码不少。谁来摸摸我头。。。
	
4. 宏不是类型定义

	。。。 该用typedef的地方还是用typedef吧。
	
# 可移植性缺陷

1. 应对C语言标准变更 -- 远古问题，比较少见了，不过不同C的编译器依然有一些表现不一或者不完全的地方。
	
2. 标示符名称的限制 -- 。。。现在还有编译器标示符不区分大小写的么？
	
3. 整数的大小 -- 对于实数类型的字节长的定义一直是没有定义的，所以要多加小心。

4. 字符是有符号整数还是无符号整数 -- 这个也是没定义的，正确方式是使用语句(unsigned int)来提高可移植性。

5. 移位运算符 

	对于移位后补0补1的问题还是没有定义的。所以如果真要使用移位运算符，能用unsigned的地方不要怜惜，在前文『奇技淫巧』中有讲到，感兴趣可以翻前文看看。

6. 内存位置0

	远古问题 -- 对于不同机器对于内存位置0的读写策略不同。
	
	所以要用null的地方要小心。如果使用C++11，就没理由不用nullptr。
	
7. 除法运算时发生的截断

	如果 q = a / b；r = a % b；
	
	性质1: q*b * r == a
	
	性质2: 改变a的正负，q的正负也会改变，但q绝对值不变
	
	性质3: 如果 b > 0， r >= 0 且r < b。
	
	可惜这三个性质不能同时成立。
	
	所以不同程序语言选择放弃其中一条。 大多数语言选择放弃第三条。C语言大多的编译器也是如此。不过有一些编译器仍然会选择放弃第二条。
	
	所以应该尽量选择使用unsigned下的类型或者尽量避免被除数为负的情况。
	
8. 随机数的大小

	远古问题 -- rand()的返回值大小不确定。
	
	现在基本都木有这个问题了。
	
9. 大小写转换 -- 该情境已经基本不成立

10. 首先释放，然后重新分配 -- 没什么好说的，现代环境基本没有这个问题




	
