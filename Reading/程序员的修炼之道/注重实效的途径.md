1. 重复的危害

	- 作为程序员，收集、组织、维护、利用知识。
	- 知识并不稳定。
	- 维护不是在应用发布时开始的。
	- 程序员持续不断地维护，在整个开发中。
	- 可靠地开发软件、并让我们的开发更利于理解和维护的唯一途径：DRY
	- DRY： 系统的每一项知识都必须具有单一、无歧义、权威的表示。
	- 冗余意味着与你的大脑记忆力斗争。这是一个迟早失败的过程。
	- 这是最重要的一个工具。

	- 重复发生的原因：
		- 强加的重复
			- 信息的多种表示
				- 过滤器
				- Code Gen
				- 让过程自动化
			- 代码中的文档
				- 糟糕的代码才需要很多注释
				- 把低级的知识反正代码里。注释用于说明
				- 把代码和注释解耦
			- 文档与代码
				- 文档与测试的关系
			- 语言问题
				- 没什么简单的技术可用于克服语言的这些需求。
		- 无意的重复
			- 有时，重复来自设计的失误。
			- 当我们拥有多个互相依赖的数据元素时，会出现一种不那么显而易见的不规范数据。
		- 无耐心的重复
			- 时间压力不可避免
			- 无耐心的重复是一种容易检测和处理的重复形式，但需要Train。
		- 开发者之间的重复
			- 最难检测
			- 不能划入某个明显区域的常用功能和数据可能会被实现多次
			- 鼓励开发者们的主动交流
	- Make It Easy to Reuse
	- 如果不容易，大家就不会去复用。
	- 不复用就有可能重复。

2. 正交性
	- 高度解耦的 == 正交的
	- Eliminate Effects Between Unrelated Things
	- 好处
		- 非正交系统的改变和控制更复杂是其固有的性质。
		- 独立
		- 单一目的
		- Well Defined
		- 组件相隔离
		- **提高生产率和降低风险**
			- 提高生产力
				- 改动得以局部化
				- 开发时间和测试时间降低
				- 促进复用
				- 进行组合可以提高生产率
			- 降低风险
				- 降低任何开发中固有的风险
				- 有问题的区域被隔离开来
				- 健壮性更强
				- 更好测试
				- Platform Independent
	- 项目团队
		- 如果组织的不正交， 责任感会困惑。
		- 如果应用功能的划分显而易见，那就照此划分，以后再调整。
		- 正交的团队效率越高。
		- 如果一个改动需要改的人也多，那么正交性不好。
	- 设计
		- 也可能被理解为 == 模块化、基于组件、分层
		- 测试正交性== 如果改动一点我需要改动多少。
		- 最好的答案是1个。
		- 问问自己： 你的设计多大程度上解除了与现实世界中的变化的耦合？
		- 不要依赖你无法控制的事物属性
	- Kit和Library
		- 做技术选型
		- 是否迫使你做代码改动？
		- 尽可能不可以不改动原来的代码
	- 编码
		- 让你的代码保持解耦
			- 尽量减少不必要的可见性
		- 避免使用全局变量
			- 把你所需的任何Context传入模块
		- 避免编写相似的函数
		- 养成不断批判对待自己的代码的习惯。Refactoring if possible.
	- 测试
		- 好的设计和实现也好测试。
		- 模块级测试更容易规定和进行。
		- 修正Bug也是评估整个系统的正交性的好时候。
		- 构建单元测试本身是正交性的一项有趣的测试。
		- 开始运用自动化
		- 进行分析和报表化
	- 文档
		- 坐标为内容和表现形式
	- 认同正交性
		- DRY原则可使系统重复降至最小。
		- 正交可使系统的组件间依赖最小。
		- 结合两者。系统会更灵活、易于理解、易于测试、调试、维护。
	- 多重继承如何影响正交性? 接口呢？ Delegate呢?

3. 可撤销性
	- 如果某个想法是你唯一的想法，再也没有比这更危险的事情了。
	- 没有什么是永远不变的。
	- 关键决策不容易撤销。
	- 与软件开发的速度相比，需求、用户、以及硬件变得更快。
	- 需求变化不应该影响开发速度很大。
	- 错误在于假定决策是浇灌在石头上的——同时还在于没有为可能出现的意外事件做准备。
	- 要把决策视为写在沙滩上，而不是刻在石头上。
	- 大浪随时可能到来，把它们抹去。
	- There are no Final Decision.
	- 还需要考虑维持架构、部署及供应商等领域的灵活性。
	- 通常可以把第三方产品隐藏在定义良好的抽象接口中。

4. 曳光弹
	- 及时反馈
	- 外部影响减少
	- 敏捷
	- 曳光飞行之所以有效是因为真的子弹在相同的环境、相同约束下工作。
	- 比较便宜
	- 曳光代码不是用过就扔的代码。写是为了保留它。工程化完善。
	- 和项目永不会结束的理念是一样的。
	- 优点:
		- 用户能够及早看到能工作的东西。
		- 构建了一个他们能在其中工作的结构。
		- 你有了一个集成平台。
		- 你有了可用于演示的东西。
		- 你将更能够感觉到工作进展。
	- 在不能100%确定该去往何处的情形下使用这些技术。
	- 不理数据和性能
	- 用所见增加用户信心。
	- 原型不会使用这个代码。
	- MVP
	- 原型制作用过就扔的代码。曳光代码简约但是完整，最终是系统骨架的一部分。

5. 原型和便笺
	- 构建原型的原因 —— 分析和揭示风险，降低代价、为修正提供机会。
	- 目的是为了回答一些问题。便宜+快。
	- 代码可以忽略不重要的细节。
	- 应做原型的：
		- 架构
		- 已有系统的新功能
		- 外部数据的结构或内容
		- 第三方工具或组件
		- 性能问题
		- 用户界面设计
	- 其制作是一种学习经验，不在于产生的代码，而在于其经验和教训。
	- 可以忽略：
		- 完整性
		- 正确性
		- 健壮性
		- 风格
	- 原型应该这比细节，并聚焦于系统的某些方面。
	- 更适合脚本语言。
	- 可以得到答案:
		- 主要组件的责任是否得到了良好的定义？是否适当？
		- 主要组件的协作是否得到Well Defined？
		- 耦合是否得以最小化？
		- 能否确定重复的潜在来源？
		- 接口定义和各项约束是否可接受？
		- **每个模块在执行过程中是否能访问到所需的数据？是否能在需要时进行访问？**
	- 必须指明这些代码是用过就扔的，它们不完整，也不可能完整。
	- 告知其他人这只是原型。给它们合理的期望。
	- 如果原型已被误解，那么还是有曳光弹、
	- 适当使用原型，可以帮助你在开发早期确定和改进潜在的问题点——便宜、容易 ——省时、力、钱，大大减少折磨和痛苦。

6. 领域语言
	1. 计算机会影响你思考问题的方式，以及你看待交流的方式。
	2. 语言的界限就是一个人的世界的界限。
	3. 采用领域的语汇、语法、语义——语言实际进行编程。
	4. Program Close to the Problem domain
	5. 实现小型语言
		- 面向行的、易于解析。
		- 拓展已有语言。
	6. 数据语言和命令语言
		- 数据语言产生某种形式的数据结构给应用使用。
		- 命令语言被实际执行。
	7. 独立语言和嵌入式语言
		- 将高级命令语言直接嵌入你的应用是一种常见做法，这样，它们就会在你的代码运行时执行。
	8. 权衡要素是可扩展性和维护。

7. 估计
	- 进行估算的过程中，你将会加深对你的程序所处的世界的理解。
	- 通过学习估算，并将此技能发展到你对事物的数量级有直觉的程度，你就能展现出一种魔法般的能力，并确定它们的可行性。
	- Estimate to Avoid Surprises
	- 要选择能反应你想要传达的准确度的单位。
	- 所有的估算都来于模型。
	- 去问已经做过这件事情的人。
	- 第一步理解内容。
	- 把握范围。
	- 根据你对于所提问题的理解，建立粗略、就绪的思维模型骨架。
	- 建模既可以是创造性的，又可以是长期有用的。
	- 建模把不确定性引入了估算过程中。这是有益的。MVP
	- 建立了模型，可以分解为组件。分解成参数。
	- 给每个参数一个指定值。
	- **采用一种合理的方式计算这些关键参数。**
	- 只有最简单的情况才有唯一的答案。
	- 不要放弃错误的答案。
	- 记录你的估算。
	- 失败了也要去理解为什么失败。
	- 估算项目进度	
		- 检查需求
		- 分析风险
		- 设计、实现、集成
		- 向用户确认
		
		- 通过代码对进度表进行迭代
		- 不要急于做估计	
	