1. 按照合约设计
	- 合约既规定你的代码与责任，也规定了对方的权利与责任。
	- DBC
		- 前条件
		- 后条件
		- 类不变性
		- 如果调用者满足了所有前条件，应该保证在其完成时、所有后条件和不变项都将为真。
		- 子类必须要能够通过基类的接口使用，而使用者无须知道其区别。
		- 没有合约，编译器能做的只是确保子类符合特定的方法型构。但如果我们适当设定基类合约，我们现在就能够确保将来任何子类都无法改变我们的方法的意义。
		- 使用DBC的最大好处也许是它迫使需求与保证的问题走到前台来。
	- 断言
		- 可以用断言对此进行部分模拟，如果有子类的情况就不行了。
	- Fail Fast
		- DBC相当符合Fail Fast。
		- 通过早崩溃、在问题现场找到和诊断问题要容易的多。
	- 不定式的其他用法
		- 循环不定式
			- 循环不变项是对循环的最终目标的陈述。
			- 可被显式地写成断言。作为设计和文档工具也很有用。
		- 语义不变项
			- 一种不可违反的需求，一种『哲学合约』
			- 不要把固定的需求、不可违反的法则与那些仅仅是政策的东西混为一谈
			- 必须是对事物的确切含义的中心，而不受反复无常的政策的支配
			- 当你发现合格的需求时，确保让它成为制作的无论什么文档的一个众所周知的部分。设法清晰、无歧义的陈述它。
	
	-  『自治』的概念，代理有拒绝它们不想接受的请求的自由。
	-  任何依赖于代理技术的系统对合约协商的依赖都是至关重要的——即使它们是动态生成的。
	-  如果我们不能手工使用合约，我们也无法自动使用它们。

2. 死程序不会说谎
	- 我们很容易掉进『它不可能发生』这样的一种心理状态。
	- 防卫性的编程
	- 所有的错误能为你提供信息。
	- 如果有一个错误发生，就说明非常、非常糟糕的事情已经发生了。
	- 尽早检查问题的好处在于你可以更早崩溃。
	- 有时简单的退出运行中的程序并不合适。
	- 当你的程序某件被认为不可能发生的事情已经发生时，你的程序就不具有存活的能力。
	- 死程序带来的危害通常比有疾患的程序要小很多。

3. 断言式编程
	- 如果它不可能发生，有断言确保它不会发生。
	- 无论何时你发现自己在思考『但那当然不可能发生』，增加代码检查它。
	- 传给断言的条件不应该有副作用。
	- 绝不要把必须执行的代码反正断言中。
	- 不要用断言代替真正的错误处理。
	- 让断言开着。
	- 乐观主义者忘了他们的代码处于危险的环境中。
	- 第一道方向是自己检查所有可能的错误，第二道是断言。
	- 也许是你的应用的关键部分，也许需要很快才行。增加检查意味又一次通过检查，这可能让人不能接受。让那个检查成为可选，但让其余的留下来。

4. 何时使用异常
	- 异常应该保留给意外事件。
	- 将异常用于异常的问题。

5. 如何配平资源
	- 要有始有终
	- 以与资源分配的持续相反的次序解除资源的分配。
	- 在代码的不同地方分配同一组资源时，总是以相同的次序分配它们。
	- 顶层结构还负责释放它包含的任何子结构。
	- 或只是解除顶层结构的分配。
	- 或如果顶层结构有任何子结构，它就拒绝解除自身的分配。
	- 如果跟踪资源很棘手，你可以通过在动态分配的对象上实现一种引用计数。
	- 构建代码、对资源配平得到了适当释放进行实际检测，这总是好主意。