1. 解耦
	- 『羞涩』的工作方式有2种：
		- 不向被人暴露你自己
		- 不与太多人打交道
	- 把你的代码组织成最小组织单位，并限制它们之间的交互。如果随后处于折中必须替换某个模块，其他模块仍能继续工作。
	- 对象间直接的横贯关系有可能很快带来依赖关系的组合爆炸。
	- 有很多不必要的依赖关系的系统非常难以维护，高度不稳定。
	- 德墨聂耳法则
		- 某个对象的任何方法都应该只调用属于以下情形的方法：
			- 它自身
			- 传入该方法的任何参数
			- 它创建的任何对象
			- 任何直接持有的组件对象
		- 遵循这一法则缩小了调用类中的响应集的规模，结果以这种方式设计的类错误往往也会更少。
		- 也有代价：带来运行时代价。空间开销。
		- 只要对于那些被耦合在一起的模块而言，这是众所周知和可以接受的，你的设计就没什么问题。

2. 元程序设计
	- 元数据是关于数据的数据。
	- 是任何对应用进行描述的数据。
	- 目标是以声明方式思考，并创建高度灵活和可适应的程序。
	- 把抽象放进代码，细节放进元数据。
	- 好处
		- 迫使你解除你设计的耦合，从而带来更灵活、可适应性更好的程序。
		- 它迫使你通过推迟细节处理，创建更强健、抽象的设计——完全推迟到程序之外。
		- 无需重新编译应用，你就可以对其进行定制。
		- 与通用的编程语言比，可以通过一种大为接近问题领域的方式表示元数据。
		- 你甚至还可以用相同的应用引擎——但用不同的元数据——实现若干不同的项目。
	- 对于不那么复制的逻辑，可以使用小型语言加以表达，从而消除在环境变化时重新编译和重新部署的需要。
	- 没有元数据，你的代码就不可能获得它应有的适应性与灵活性。
	- 不要让你的项目走向渡渡鸟的道路。

3. 时间耦合
	 - 我们需要容许并发，并考虑解除任何时间或次序上的依赖。这样做，我们可以获得灵活性，并减少许多开发领域中的任何基于时间的依赖：工作流分析、架构、设计、还有部署。
	 - 工作流
	 	- 可以通过动作图找到本来可以、却没有并行的活动。
	 - 架构
	 	- 实际上我们创建的不是组件，而是服务——位于Well Defined、一致的接口之后的独立、并发的对象。
	 - 多线程编程施加了某些设计约束——这是一件好事情。那些约束实际上是如此有益，以至于只要我们编程，我们就应该遵循它们。它们将帮助代码的耦合，而非靠巧合编程。
	 - 并发迫使你更仔细对事情进行思考。你可能会突然看到某些基于时间的依赖关系。
	 - 有利于重新思考静态或全局变量。
	 - 能引导你设计更简洁的接口。
	 - Always Design for Concurrency
	 - 部署
	 	- 以上都做好了，这一步会很简单。

4. 它只是View
	- Pub-Sub
	- MVC
		- Separate Views from Models
		- Model -- 目标对象的抽象数据模型。
		- View -- 解释模型的方式
		- Controller -- 控制试图、并向模型提供新数据的途径。

5. 黑板
	 - Easy Interface。Good for reducing the combination of Interfaces。
	 - 组织黑板。
	 - Use Blackboards to Coordinate Workflow
	 - 用黑板协调完全不同的事实和因素，同时又使各参与方保持独立、甚至隔离。
